### 아이템 66 네이티브 메서드는 신중히 사용하라
- 자바 네이티브 인터페이스 (Java Native Interface, JNI)는 자바 프로그램이 네이티브 메서드를 호출하는 기술
  - 네이티브 메서드: C나 C++같은 네이티브 프로그래밍 언어로 작성한 메서드를 말함
    - **기능 1. 레지스트리 같은 플랙폼 특화 기능을 사용**
      - 자바도 성숙해가면서 (OS 같은) 하부 플랫폼의 기능들을 점차 흡수하고 있음
      - 예를 들어 자바 9은 process API를 추가해 OS 프로세스에 접근하는 길을 열어줌
      - 네이티브 메서드를 사용할 필요성이 줄어들고 있음
    - **기능 2. 네이티브 코드로 작성된 기존 라이브러리 사용** (레거시 데이터를 사용하는 레거시 라이브러리)
    - **기능 3. 성능 개선을 목적으로 성능에 결정적인 영향을 주는 영역만 따로 네이티브 언어로 작성**
      - **거의 권장하지 않음**
      - 자바 초기 시절 (java 3 전)이라면 이야기가 다르지만, JVM이 그동안 엄청난 속도로 발전해옴
      - 예를 들어 java.math가 처음 추가된 java 1.1 버전에서 BigInteger는 C로 작성한 고성능 라이브러리에 의지
      - java 3 때 순수 자바로 다시 구현되면서 세심히 튜닝한 결과, 네이티브 구현보다도 더 빨라졌다
      - 그치만 java 8에서 큰 수의 곱셈 성능을 개선한 것을 제외하고는 BigInteger에 큰 변화는 없었다
      - 한편 네이티브 라이브러리 쪽은 GNU 다중 정밀 연산 라이브러리(GMP)를 필두로 개선 작업이 계속되어 다중 정밀 연산이 필요하다면 네이티브 메서드를 통해 GMP를 사용하는 걸 고려해도 좋음
    - 심각한 단점
      - 이식성이 낮고, 디버깅도 어렵고, 오히려 느려질 수 이음.
      - 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 못하고, 추적조차 할 수 없다. 네이티브 메서드와 자바 코드 사이의 접착 코드(glue code) 작성도 귀찮음

### 아이템 67 최적화는 신중히 하라
```
💡 최적화 격언 세 개

- (맹목적인 어리석음을 포함해) 그 어떤 핑계보다 효율성이라는 이름 아래 행해진 컴퓨터 죄악이 더 많다 (심지어 효율을 높이지도 못하면서)

- (전체의 97% 정도인) 자그마한 효율성은 모두 잊자. 섣부른 최적화가 만악의 근원이다.

- 최적화를 할 때는 다음 두 규칙을 따르라.
  - 첫 번째, 하지 마라.
  - 두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완전히 명백하고 최적화되지 않은 해법을 찾을 때까지는 하지 마라.
```

- **성능 때문에 견고한 구조를 희생하지 말자. 빠른 프로그램보다는 좋은 프로그램을 작성하라.**
  - 성능이 나오지 않는다면 그 아키텍처 자체가 최적화할 수 있는 길을 안내해줄 것
  - 좋은 프로그램은 정보 은닉 원칙을 따르므로 개별 구성요소의 내부를 독립적으로 설계할 수 있다
  - 따라서 시스템의 나머지에 영향을 주지 않고도 각 요소를 다시 설계할 수 있다
- 구현상의 문제는 최적화를 통해 해결할 수 있지만, 아키텍처의 결함이 성능을 제한하는 상황이라면 시스템 전체를 다시 작성하지 않고는 해결이 불가능하다
  - 완성된 설계의 기본 틀을 변경하려다 보면 유지보수하거나 개선하기 어려운 꼬인 구조의 시스템이 만들어지기 쉽기 때문이다.
  - 따라서 설계 단계에서 성능을 반드시 염두에 두어야 한다
- 성능을 제한하는 설계를 피하라
  - 완성 후 변경하기 어려운 설계요소는 바로 컴포넌트끼리, 혹은 외부 시스템과의 소통 방식 (API, 네트워크 프로토콜, 데이터 포맷 등)
- API를 설계할 때 성능에 주는 영향을 고려하라
- 프로파일링 도구는 최적화 노력을 어디에 집중해야 할지 찾는 데 도움을 준다

### 아이템 68 일반적으로 통용되는 명명 규칙을 따르라
java 명명 규칙 (철자 & 문법) <--- 자바 언어 명세 JLS, 6.1에 기술되어 있음
- 철자 규칙
  - 패키지 이름은 각 요소를 점으로 구분하여 계층적으로 짓는다. 외부에서도 사용될 패키지라면 인터넷 도메인 이름 역순으로 사용 (각 요소는 8글자 이하의 짧은 단어로 한다)
  - 클래스와 인터페이스의 이름은 하나 이상의 단어로 이뤄지며, 대문자로 시작. 통용되는 줄임말을 제외하고는 단어를 줄여 쓰지 않도록 함
  - 메서드와 필드 이름은 첫 글자를 소문자로 쓴다는 점만 빼면 클래스 명명 규칙과 같음
  - 상수 필드를 구성하는 단어는 모두 대문자로 쓰며 단어 사이는 밑줄로 구분한다
  - 지역 변수, 일반 매개변수도 비슷한 명명 규칙이 적용되며, 약어를 써도 좋음
  - 타입 매개 변수 이름은 한 문자로 표현. (임의의 타입: T, 컬렉션 원소: E, 맵의 키와 값에는 K & V, 예외에는 X, 메서드 반환 타입에는 R, 시퀀스 T & U & V)
- 문법 규칙
  - 철자 규칙에 비해 논란도 많고, 더 유연하다
  - 객체를 생성할 수 있는 클래스의 이름은 명사나 명사구를 사용 (Thread, PriorityQueue, ChesePiece 등)
  - 객체를 생성할 수 없는 클래스의 이름은 보통 복수형 명사를 사용 (Collectors, Collections 등)
  - 인터페이스 이름은 클래스와 똑같이 짓거나 able 혹은 ible로 끝나는 형용사로 짓는다 (Runnable, Iterable, Accessible)
  - 동작을 수행하는 메서드의 이름은 동사나 동사구를 사용 (append, drawImage)
  - boolean을 반환하는 메서드는 is 혹은 has로 시작 (isDigit, isEmpty, hasSiblings 등)
  - 해당 인스턴스의 속성을 반환하는 메서드의 이름은 보통 명사, 명사구, get으로 시작하는 동사구로 짓는다 (size, hashCode, getTIme 등)
  - 객체의 타입을 바꿔서 반환하는 메서드의 이름은 toType (toString, toArray 등)
  - 객체의 내용을 다른 뷰로 보여주는 메서드의 이름은 asType (asList 등)
  - 객체의 값을 기본 타입 값으로 반환하는 메서드의 이름은 typeValue (intVlaue 등)
  - 정적 팩터리의 이름은 from, of, valueOf, instance, getInstsance, newInstance, getType, newType
