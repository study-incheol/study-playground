## 📌 인상 깊었던 내용
> 스택 오버플로 역사상 가장 유명한 질문은 " 왜 정렬되지 않은 배열을 처리하는 것보다 정렬된 배열을 처리하는 것이 더 빠를까?" 이다.
> 실행 시간을 최적화하기 위해 CPU는 실행 코드보다 선제적으로 움직여 필요하기 전에 미리 준비한다.
> 이럴 때 CPU가 사용하는 기술을 **분기 예측(branch prediction)** 이라고 한다.
>
> 📕 p.244 7장

### 🥸: 정렬된 배열은 CPU가 순서와 분기를 올바르게 예측할 수 있기 때문에 성능이 더 우수하다. 

## 📌 이해가 가지 않았던 내용
> 프로그래밍에서 가장 오해 받는 개념 중 하나는 비동기 I/O이다. 작업을 별도의 코어에서 실행하기 때문에 모든 종류의 작업을 떠 빠르게 수행하기 위한 병렬화 모델인 멀티스레딩과 혼동하는 경우가 많다.
> 비동기 I/O는 I/O 부하가 높은 작업만을 위한 병렬화 모델이며 단일 코어에서 작동할 수 있다. 멀티스레딩과 비동기 I/O는 서로 다른 목적을 위해 활용되며 함께 사용할 수도 있다.
> I/O는 자연스럽게 비동기적이다. 하드웨어에 I/O 작업이 할당되면 하드웨어가 그 작업을 실행하는 동안 CPU는 다른 작업을 계속 처리할 수 있으며, I/O 작업이 완료될 때 다시 그 결과를 확인할 수 있다.
> 이러한 메커니즘이 비동기 I/O의 기초가 된다.
>
> 📕 p.252 7장

> 추가적인 작업 없이 코드에 자연스러운 병렬화를 제공하는 데 있다. 스레드를 추가로 만들 필요도 없다. 실용적이며 확장 가능하다.

### 🥸: 기존처럼 사용하면 된다는 얘기일까?


## 📌 논의해보고 싶었던 내용

> 캐싱을 위해 설계되지 않은 데이터 구조는 사용하지 마라. 보통 오래된 데이터를 제거하거나 만료하는 메커니즘이 없기 때문에 메모리 누수의 원인이 되고, 결국에는 충돌하게 된다. 캐싱을 위해 설계된 것을 사용하라.
> 데이터베이스는 훌륭하고 영구적인 캐시가 될 수도 있다. 캐시 만료 시간이 무한대인 것을 두려워하지 마라. 이 우주가 끝나기 전에 캐시가 제거되거나 애플리케이션 재시작이 이뤄질 것이다.
>
> 📕 p.256 7장

### 🥸: 캐시 만료 시간이 무한대라면 왜 캐시를 사용하는가?
