# 1.4. Dependencies

> [1.4. Dependencies](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies) 챕터를 요약한 내용입니다.

일반적인 엔터프라이즈 애플리케이션은 단일 객체로 구성되지 않는다. 가장 단순한 어플리케이션도 최종 사용자가 일관된 어플리케이션을 보여주기 위해 함께 동작하는 몇 가지 객체가 있다. 이번 섹션에서는 독립된 많은 빈 정의를 하는 것이 어떻게 목적을 이루기 위해 객체가 협력하는 완전한 애플리케이션으로 바뀔 수 있는지 설명한다.

## 1.4.1. Dependency Injection

의존성 주입(Dependency Injection : DI)은 객체가 생성자 인자, 팩토리 메소드에 대한 인자, 생성자에 의해 생성되거나 팩토리 메소드로 반환된 객체 인스턴스에 설정된 속성을 통해서만 객체의 의존성을 정의하는 프로세스다. 그런 다음 컨테이너는 빈을 생성할 때 이러한 의존성을 주입한다. 이 프로세스는 근본적으로 클래스의 생성자 또는 서비스 로케이터 패턴을 사용하여 자체적으로 객체화 또는 의존성의 위치를 제어하는 빈 자체의 역 과정이다. (Inversion of Control)

DI는 크게 두 가지 형태로 존재한다: *생성자 기반 의존성 주입* 과 *세터 기반 의존성 주입*.

### 생성자 기반 의존성 주입(Constructor-based Dependency Injection)

생성자 기반 DI는 컨테이너가 각각 의존성을 나타내는 여러 인자로 생성자를 호출하여 수행된다. 빈을 구성하기 위해 특정 인자를 사용하여 정적 팩토리 메소드를 호출하는 것은 거의 동일하며 이 설명에서는 생성자와 정적 팩토리 메소드에 대한 인자를 유사하게 다룬다. 다음 예제에서는 생성자 주입으로만 의존성을 주입할 수 있는 클래스를 보여준다.

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on a MovieFinder
    private final MovieFinder movieFinder;

    // a constructor so that the Spring container can inject a MovieFinder
    public SimpleMovieLister(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

이 클래스에는 특별한 것이 없다. 컨테이너 특정 인터페이스, 베이스 클래스 또는 어노테이션과 관련이 없는 POJO이다.

{% hint style="success" %}

#### 💡 POJO?

Plain Old Java Object, 간단히 POJO는 말 그대로 해석을 하면 오래된 방식의 간단한 자바 오브젝트라는 말로서 Java EE 등의 중량 프레임워크들을 사용하게 되면서 해당 프레임워크에 종속된 "무거운" 객체를 만들게 된 것에 반발해서 사용되게 된 용어이다. POJO라는 용어는 이후에 주로 특정 자바 모델이나 기능, 프레임워크 등을 따르지 않은 자바 오브젝트를 지칭하는 말로 사용되었다. 스프링 프레임워크는 POJO 방식의 프레임워크이다.

{% endhint %}

### 생성자 인자 해결(Constructor Argument Resolution)

생성자 인자 해결 매칭은 인자 타입을 사용하여 일어난다. 빈 정의의 생성자 인자에 잠재적인 모호성이 존재하지 않는 경우 생성자 인자가 빈 정의에 정의된 순서는 빈이 인스턴스화될 때 해당 인자가 적절한 생성자에 제공되는 순서이다. 다음 클래스에서 생각해보자.

```java
package x.y;

public class ThingOne {

    public ThingOne(ThingTwo thingTwo, ThingThree thingThree) {
        // ...
    }
}
```

ThingTwo 및 ThingThree 클래스가 상속에 의해 관련되지 않는다고 가정하면 잠재적 모호성이 존재하지 않는다. 따라서 밑의 다음 구성이 제대로 동작하며 `<constructor-arg/>` 요소에 생성자 인자 인덱스 또는 타입을 명시적으로 지정할 필요가 없다.

```xml
<beans>
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg ref="beanTwo"/>
        <constructor-arg ref="beanThree"/>
    </bean>

    <bean id="beanTwo" class="x.y.ThingTwo"/>

    <bean id="beanThree" class="x.y.ThingThree"/>
</beans>
```

앞의 예와 같이 다른 빈이 참조될 때 타입을 알고 매칭이 일어난다. `<value>true</value>`와 같은 단순한 타입을 사용하는 경우 스프링은 값의 타입을 판별할 수 없으므로 도움 없이 타입별로 일치시킬 수 없다. 다음 클래스에서 생각해보자.

```java
package examples;

public class ExampleBean {

    // Number of years to calculate the Ultimate Answer
    private final int years;

    // The Answer to Life, the Universe, and Everything
    private final String ultimateAnswer;

    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

#### 생성자 인자 타입 매칭(Constructor argument type matching)

앞의 예제에서 컨테이너는 다음 밑의 예제와 같이 `타입의 유형`을 사용하여 생성자 인자의 타입을 명시적으로 지정하는 경우 단순 타입과의 타입 매칭을 사용할 수 있다.

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg type="int" value="7500000"/>
    <constructor-arg type="java.lang.String" value="42"/>
</bean>
```

#### 생성자 인자 인덱스(Constructor argument index)

다음 밑의 예제와 같이 `인덱스` 속성을 사용하여 생성자 인자의 인덱스를 명시적으로 지정할 수 있다.

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg index="0" value="7500000"/>
    <constructor-arg index="1" value="42"/>
</bean>
```

여러 단순한 값의 모호성을 해결하는 것 외에도 인덱스를 지정하면 생성자에 동일한 타입의 두 인자가 있는 경우의 모호성도 해결된다.

> 📋 **인덱스는 0부터 시작한다.**

#### 생성자 인자 이름(Constructor argument name)

다음 밑의 예제와 같이 값 모호성을 없애기 위해 생성자 파라미터 이름을 사용할 수도 있다.

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <constructor-arg name="years" value="7500000"/>
    <constructor-arg name="ultimateAnswer" value="42"/>
</bean>
```

이 작업을 기본적으로 수행하려면 스프링이 생성자에서 파라미터 이름을 조회할 수 있도록 코드를 디버그 플래그가 활성화된 상태로 컴파일해야 한다. 디버그 플래그로 코드를 컴파일할 수 없거나 컴파일하지 않으려면 [@ConstructorProperties](https://docs.oracle.com/javase/8/docs/api/java/beans/ConstructorProperties.html) JDK 주석을 사용하여 생성자 인자의 이름을 명시적으로 지정할 수 있다. 샘플 클래스는 다음과 같다.

```java
package examples;

public class ExampleBean {

    // Fields omitted

    @ConstructorProperties({"years", "ultimateAnswer"})
    public ExampleBean(int years, String ultimateAnswer) {
        this.years = years;
        this.ultimateAnswer = ultimateAnswer;
    }
}
```

\

### Setter 기반 의존성 주입(Setter-based Dependency Injection)

setter 기반 DI는 빈을 인스턴스화하기 위해 인자가 없는 생성자 또는 인자가 없는 정적 팩토리 메서드를 호출한 후 빈에서 setter 메서드를 호출하는 컨테이너에 의해 수행된다.

다음 밑의 예제는 순수 setter 주입을 사용해야만 의존성 주입이 가능한 클래스를 보여준다. 이 클래스는 전형적인 자바 코드이다. 컨테이너의 특정 인터페이스, 베이스 클래스 또는 어노테이션에 대한 의존성이 없는 POJO다.

```java
public class SimpleMovieLister {

    // the SimpleMovieLister has a dependency on the MovieFinder
    private MovieFinder movieFinder;

    // a setter method so that the Spring container can inject a MovieFinder
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // business logic that actually uses the injected MovieFinder is omitted...
}
```

`ApplicationContext`는 관리하는 빈에 대해 생성자 기반 및 setter 기반 DI를 지원한다. 또한 생성자 접근 방식을 통해 일부 의존성이 이미 주입된 후 setter 기반 DI를 지원하기도 한다. 속성을 한 형식에서 다른 형식으로 변환하기 위해 `PropertyEditor` 인스턴스와 함께 사용하는 `BeanDefinition` 형식으로 의존성을 구성한다. 그러나 대부분의 스프링 사용자는 이러한 클래스를 직접(즉, 프로그래밍 방식으로) 사용하지 않고 XML 빈 정의나 어노테이션이 달린 구성 요소(즉, `@Component`, `@Controller` 등으로 어노테이션이 달린 클래스) 또는 Java 기반 `@Configuration` 클래스안의 `@Bean` 메소드를 사용한다. 그런 다음 이러한 소스는 내부적으로 `BeanDefinition`의 인스턴스로 변환되고 전체 Spring IoC 컨테이너 인스턴스를 불러오는데 사용된다.

{% hint style="success" %}

> #### 💡 Constructor-based or setter-based DI?
>
> 생성자 기반 및 setter 기반 DI를 혼합할 수 있으므로 필수 의존성에는 생성자를 사용하고 선택적 의존성에는 setter 메서드 또는 configuration 메서드를 사용하는 것이 좋다. setter 메서드에서 [@Required](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-required-annotation) 어노테이션을 사용하여 속성을 필수 의존성으로 만들 수 있다. 그러나 프로그래밍 방식의 인자 유효성 검사가 포함된 생성자 주입이 더 좋다.
>
> 스프링팀은 일반적으로 생성자 주입을 지지한다. 생성자 주입을 사용하면 애플리케이션 구성 요소를 변경할 수 없는 객체로 구현할 수 있고 필요한 의존성이 null이 아님을 확인할 수 있기 때문이다. 또한 생성자 주입 구성 요소는 항상 완전히 초기화된 상태로 클라이언트(호출) 코드에 반환된다. 참고로 많은 수의 생성자 인자는 나쁜 코드 스멜이고, 이는 클래스에 너무 많은 책임이 있을 수 있으며 적절한 문제로 분리를 더 잘 처리하기 위해 리팩토링해야 함을 의미한다.
>
> Setter 주입은 주로 클래스 내에서 합리적인 default값을 할당할 수 있는 선택적 종속성에만 사용해야 한다. 그렇지 않으면 코드에서 의존성을 사용하는 모든 곳에서 null이 아닌지 검사를 수행해야 한다. setter 주입의 한 가지 이점은 setter 메서드가 해당 클래스의 오브젝트를 나중에 재구성하거나 다시 주입할 수 있다는 것이다. 따라서 [JMX MBeans](https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#jmx)를 통한 관리는 setter 주입을 위한 매력적인 사용 사례이다.
>
> 특정 클래스에 가장 적합한 DI 스타일을 사용하라. 때로는 소스가 없는 서드 파티 클래스를 처리할 때 선택이 이루어진다. 예를 들어, 서드 파티 클래스가 setter 메서드를 노출하지 않는 경우 생성자 주입이 유일하게 사용 가능한 DI 형식일 수 있다.

{% endhint %}

\

### 의존성 해결 프로세스(Dependency Resolution Process)

컨테이너는 다음과 같이 빈 의존성 해결을 수행한다.

- `ApplicationContext`는 모든 빈을 설명하는 configuration 메타데이터로 생성되고 초기화된다. configuration 메타데이터는 XML, Java 코드 또는 어노테이션으로 지정할 수 있다.

- 각 빈의 의존성은 속성, 생성자 인자 또는 정적 팩토리 메서드(일반 생성자 대신 사용하는 경우)에 대한 인자의 형태로 표현된다. 이러한 의존성은 빈이 실제로 생성될 때 빈에 제공된다.

- 각 속성 또는 생성자 인자는 설정할 값의 실제 정의이거나 컨테이너의 다른 빈에 대한 참조이다.

- 값인 각 속성 또는 생성자 인수는 지정된 형식에서 해당 속성 또는 생성자 인자의 실제 타입으로 변환된다. 기본적으로 스프링은 문자열 타입으로 제공된 값을 int, long, String, boolean 등과 같은 모든 내장 타입으로 변환할 수 있다.

스프링 컨테이너는 컨테이너가 생성될 때 각 빈의 configuration을 검증한다. 그러나 빈 속성 자체는 빈이 실제로 생성될 때까지 설정(set)되지 않는다. 싱글톤이고 사전 인스턴스화되도록 설정된(default) 빈은 컨테이너가 생성될 때 생성된다. 범위는 빈 범위에서 정의된다. 그렇지 않으면 요청될 때만 빈이 생성된다. 빈의 생성은 빈의 의존성과 의존성의 의존성(등)이 생성되고 할당됨에 따라 잠재적으로 빈의 그래프가 생성되도록 하고있다. 이러한 의존성 간의 해결 불일치는 늦게, 즉 영향을 받는 빈을 처음 생성할 때 나타날 수도 있다.

{% hint style="success" %}

> #### 💡 Circular dependencies
>
> 주로 생성자 주입을 사용하는 경우 해결할 수 없는 순환 의존성 시나리오를 만들 수 있다.
>
> 예: 클래스 A는 생성자 주입을 통해 클래스 B의 인스턴스가 필요하고 클래스 B는 생성자 주입을 통해 클래스 A의 인스턴스가 필요한 상황이다. 클래스 A와 B의 빈을 서로 주입하도록 구성하면 Spring IoC 컨테이너는 런타임에 이 순환 참조를 감지하고 `BeanCurrentlyInCreationException`을 발생시킨다.
>
> 한 가지 가능한 솔루션은 생성자가 아닌 setter에 의해 구성되도록 일부 클래스의 소스 코드를 수정하는 것이다. 또는 생성자 주입을 피하고 setter 주입만 사용할 수 도 있다. 권장하지는 않지만 setter 주입으로 순환 의존성을 구성할 수 있다.
>
> 순환 의존성이 없는 일반적인 경우와 달리 빈 A와 빈 B 사이의 순환 의존성은 자체적으로 완전히 초기화되기 전에 빈 중 하나가 다른 빈에 주입되도록 해야한다(고전적인 닭과 달걀 시나리오로 볼 수 있다).

{% endhint %}

\

일반적으로 스프링이 올바른 일을 한다고 신뢰할 수 있다. 컨테이너 로드 시 존재하지 않는 빈 및 순환 의존성에 대한 참조와 같은 configuration 문제를 감지한다. 스프링은 빈이 실제로 생성될 때 가능한 한 늦게 속성을 설정하고 의존성을 해결한다. 이는 올바르게 로드된 스프링 컨테이너가 나중에 객체를 요청할 때 해당 객체 또는 해당 객체의 의존성 중 하나를 생성하는 데 문제가 있는 경우 예외를 발생시킬 수 있음을 의미한다. 일부 configuration 문제가 늦게 보여질 수 있기 때문에 `ApplicationContext` 구현이 기본적으로 싱글톤 빈을 미리 인스턴스화한다. 이러한 빈이 실제로 필요하기 전에 생성하기 위해 약간의 선행 시간과 메모리를 대가로 `ApplicationContext`가 생성될 때 미리 configuration 문제를 발견하게 된다. 싱글톤 빈이 사전 인스턴스화되지 않고 늦게 초기화되도록 이 default 동작을 override할 수 있다.

순환 의존성이 없는 경우 하나 이상의 빈이 의존하는 빈에 주입될 때 주입되는 각 빈은 주입되기 전에 완전히 구성된다. 즉, 빈 A가 빈 B에 의존되어 있으면 스프링 IoC 컨테이너는 빈 A에 대한 setter 메서드를 호출하기 전에 빈 B를 완전히 구성한다. 즉, 빈은 의존성이 해결되고 인스턴스화되고(사전 인스턴스화된 싱글톤이 아닌 경우) 관련 수명 주기 메서드(예: [configured init method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) 또는 [InitializingBean callback method](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-lifecycle-initializingbean) )가 호출된다.

### 의존성 주입의 예(Examples of Dependency Injection)

다음 밑의 예에서 setter 기반 DI에 대해 XML 기반 configuration 메타데이터를 사용한다. 스프링 XML configuration 파일의 일부분은 다음과 같이 일부 빈 정의를 지정한다.

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- setter injection using the nested ref element -->
    <property name="beanOne">
        <ref bean="anotherExampleBean"/>
    </property>

    <!-- setter injection using the neater ref attribute -->
    <property name="beanTwo" ref="yetAnotherBean"/>
    <property name="integerProperty" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

다음 밑 예제는 해당 `ExampleBean` 클래스를 보여준다.

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public void setBeanOne(AnotherBean beanOne) {
        this.beanOne = beanOne;
    }

    public void setBeanTwo(YetAnotherBean beanTwo) {
        this.beanTwo = beanTwo;
    }

    public void setIntegerProperty(int i) {
        this.i = i;
    }
}
```

앞의 예에서 setter는 XML 파일에 지정된 속성과 일치하도록 선언되었다. 다음 밑의 예제에서는 생성자 기반 DI를 사용한다.

```xml
<bean id="exampleBean" class="examples.ExampleBean">
    <!-- constructor injection using the nested ref element -->
    <constructor-arg>
        <ref bean="anotherExampleBean"/>
    </constructor-arg>

    <!-- constructor injection using the neater ref attribute -->
    <constructor-arg ref="yetAnotherBean"/>

    <constructor-arg type="int" value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

다음 밑 예제는 해당 `ExampleBean` 클래스를 보여준다.

```java
public class ExampleBean {

    private AnotherBean beanOne;

    private YetAnotherBean beanTwo;

    private int i;

    public ExampleBean(AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {
        this.beanOne = anotherBean;
        this.beanTwo = yetAnotherBean;
        this.i = i;
    }
}
```

빈 정의에 지정된 생성자 인자는 `ExampleBean`의 생성자에 대한 인자로 사용된다.

이제 생성자를 사용하는 대신 객체의 인스턴스를 반환하기 위해 정적 팩토리 메소드를 호출하도록 스프링에 지시되는 이 예제의 변형을 생각해보자.

```xml
<bean id="exampleBean" class="examples.ExampleBean" factory-method="createInstance">
    <constructor-arg ref="anotherExampleBean"/>
    <constructor-arg ref="yetAnotherBean"/>
    <constructor-arg value="1"/>
</bean>

<bean id="anotherExampleBean" class="examples.AnotherBean"/>
<bean id="yetAnotherBean" class="examples.YetAnotherBean"/>
```

다음 밑 예제는 해당 `ExampleBean` 클래스를 보여준다.

```java
public class ExampleBean {

    // a private constructor
    private ExampleBean(...) {
        ...
    }

    // a static factory method; the arguments to this method can be
    // considered the dependencies of the bean that is returned,
    // regardless of how those arguments are actually used.
    public static ExampleBean createInstance (AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) {

        ExampleBean eb = new ExampleBean (...);
        // some other operations...
        return eb;
    }
}
```

정적 팩토리 메소드에 대한 인자는 `<constructor-arg/>` 요소에 의해 제공된다.(생성자 방법과 정확하게 동일하다) 팩토리 메소드에 의해 반환되는 클래스의 타입은 정적 팩토리 메소드를 포함하는 클래스와 동일한 타입일 필요는 없다(이 예에서는 동일하다). 인스턴스(non-static) 팩토리 메소드는 본질적으로 동일한 방식으로 사용될 수 있으므로(`class` 속성 대신 `factory-bean` 속성을 사용하는 것을 제외하고), 여기서는 이러한 세부사항에 대해 논의하지 않는다.

## 1.4.2. Dependencies and Configuration in Detail

이전 [섹션](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators) 에서 언급했듯이 다른 관리되는 빈(collaborators)에 대한 참조 또는 인라인으로 정의된 값으로 빈 속성과 생성자 인자를 정의할 수 있다. 스프링의 XML 기반 configuration 메타데이터는 이를 위해 `<property/>` 및 `<constructor-arg/>` 요소 내에서 하위 요소를 지원한다.

### Straight Values (Primitives, Strings, and so on)

`<property/>` 요소의 `value` 속성은 속성 또는 생성자 인자를 사람이 읽을 수 있는 문자열 표현으로 지정한다. 스프링의 [변환 서비스](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#core-convert-ConversionService-API) 는 이러한 값을 `String`에서 속성 또는 인자의 실제 타입으로 변환하는 데 사용된다. 다음 밑의 예에서는 설정되는 다양한 값을 보여준다.

```xml
<bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <!-- results in a setDriverClassName(String) call -->
    <property name="driverClassName" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
    <property name="username" value="root"/>
    <property name="password" value="misterkaoli"/>
</bean>
```

다음 밑 예제에서는 보다 간결한 XML 구성을 위해 [p-namespace](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace) 를 사용한다.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
    https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="myDataSource" class="org.apache.commons.dbcp.BasicDataSource"
          destroy-method="close"
          p:driverClassName="com.mysql.jdbc.Driver"
          p:url="jdbc:mysql://localhost:3306/mydb"
          p:username="root"
          p:password="misterkaoli"/>

</beans>
```

앞쪽의 XML이 더 간결하다. 그러나 빈 정의를 생성할 때 자동 속성 완성을 지원하는 IDE(예: [IntelliJ IDEA](https://www.jetbrains.com/idea/) 또는 [Spring Tools for Eclipse](https://spring.io/tools) )를 사용하지 않는 한 오타는 디자인 타임이 아닌 런타임에 발견된다. 이러한 IDE 사용을 적극 권장한다.

다음과 같이 `java.util.Properties` 인스턴스를 구성할 수도 있다.

```xml
<bean id="mappings"
class="org.springframework.context.support.PropertySourcesPlaceholderConfigurer">

    <!-- typed as a java.util.Properties -->
    <property name="properties">
        <value>
            jdbc.driver.className=com.mysql.jdbc.Driver
            jdbc.url=jdbc:mysql://localhost:3306/mydb
        </value>
    </property>
</bean>
```

스프링 컨테이너는 자바빈의 `PropertyEditor` 메커니즘을 사용하여 `<value/>` 요소 내부의 텍스트를 `java.util.Properties` 인스턴스로 변환한다. 이것은 좋은 방법이며 스프링 팀이 `value` 속성 스타일보다 중첩된 `<value/>` 요소의 사용을 선호하는 몇 안 되는 부분중 하나이다.

#### The `idref` element

`idref` 요소는 컨테이너에 있는 다른 빈의 `id`(참조가 아닌 문자열 값)를 `<constructor-arg/>` 또는 `<property/>` 요소에 전달하는 오류 방지 방법이다. 다음 밑의 예제에서 사용 방법을 보여준다.

```xml
<bean id="theTargetBean" class="..."/>

<bean id="theClientBean" class="...">
    <property name="targetName">    
        <idref bean="theTargetBean"/>
    </property>
</bean>
```

앞의 빈 정의 부분은 런타임 동안 다음 밑의 부분과 정확히 동일하게 하다.

```xml
<bean id="theTargetBean" class="..." />

<bean id="client" class="...">
    <property name="targetName" value="theTargetBean"/>
</bean>
```

첫 번째 형식이 두 번째 형식보다 선호된다. `idref` 태그를 사용하면 컨테이너가 배포되는 때에 참조되고 명명된 빈이 실제로 존재하는지 확인할 수 있기 때문이다. 두 번째 변형에서는 `client` 빈의 `targetName` 속성에 전달된 값에 대해 유효성 검사가 수행되지 않는다. 오타는 `client` 빈이 실제로 인스턴스화될 때만 발견된다(대부분 치명적인 결과와 함께 발견된다). `client` 빈이 [프로토타입](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes) 빈인 경우 이 오타와 결과 예외는 컨테이너가 배포된 후 오랜 시간이 지나야 발견될 수 있다.

`<idref/>` 요소가 값을 가져오는 흔한 부분(적어도 Spring 2.0 이전 버전에서는)은 `ProxyFactoryBean` 빈 정의의 [AOP 인터셉터](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop-pfb-1) 구성안에 있다. 인터셉터 이름을 지정할 때 `<idref/>` 요소를 사용하면 인터셉터 ID의 철자가 틀리는 것을 방지할 수 있다.

### References to Other Beans (Collaborators)

`ref` 요소는 `<constructor-arg/>` 또는 `<property/>` 정의 요소 내부의 마지막 요소이다. 여기에서 빈의 지정된 속성 값을 컨테이너가 관리하는 다른 빈(collaborator)에 대한 참조가 되도록 설정한다. 참조된 빈은 속성을 설정할 빈의 의존성이 되며 속성이 설정되기 전에 필요에 따라 초기화된다. (collaborator가 싱글톤 빈인 경우 컨테이너에 의해 이미 초기화되었을 수 있다.) 모든 참조는 궁극적으로 다른 객체에 대한 참조이다. 범위 지정 및 유효성 검사는 `bean` 또는 `parent` 속성을 통해 다른 객체의 ID 또는 이름을 지정하는지 여부에 따라 다르다.

`<ref/>` 태그의 `bean` 속성을 통해 대상 빈을 지정하는 것이 가장 일반적인 형식이며 동일한 XML 파일에 있는지 여부에 관계없이 동일한 컨테이너 또는 상위 컨테이너에 있는 모든 빈에 대한 참조를 생성할 수 있다. `bean` 속성의 값은 대상 빈의 `id` 속성과 같거나 대상 빈의 `name` 속성 값 중 하나와 같을 것이다. 다음 밑의 예는 `ref` 요소를 사용하는 방법을 보여준다.

```xml
<ref bean="someBean"/>
```

`parent` 속성을 통해 대상 빈을 지정하면 현재 컨테이너의 부모 컨테이너에 있는 빈에 대한 참조가 생성된다. `parent` 속성의 값은 대상 빈의 `id` 속성 또는 대상 빈의 `name` 속성에 있는 값 중 하나와 동일할 것이다. 대상 빈은 현재 컨테이너의 상위 컨테이너에 있어야 한다. 컨테이너 계층이 있고 부모 빈과 동일한 이름을 가진 프록시로 부모 컨테이너의 기존 빈을 래핑하려는 경우 주로 이 빈 참조 변형을 사용해야 한다. 다음 밑의 예제 쌍은 `parent` 속성을 사용하는 방법을 보여준다.

```xml
<!-- in the parent context -->
<bean id="accountService" class="com.something.SimpleAccountService">
    <!-- insert dependencies as required here -->
</bean>
```

```xml
<!-- in the child (descendant) context -->
<bean id="accountService" <!-- bean name is the same as the parent bean -->
    class="org.springframework.aop.framework.ProxyFactoryBean">
    <property name="target">
        <ref parent="accountService"/> <!-- notice how we refer to the parent bean -->
    </property>
    <!-- insert other configuration and dependencies as required here -->
</bean>
```

### Inner Beans

`<property/>` 또는 `<constructor-arg/>` 요소 내부의 `<bean/>` 요소는 다음 밑의 예제와 같이 내부 빈을 정의한다.

```xml
<bean id="outer" class="...">
    <!-- instead of using a reference to a target bean, simply define the target bean inline -->
    <property name="target">
        <bean class="com.example.Person"> <!-- this is the inner bean -->
            <property name="name" value="Fiona Apple"/>
            <property name="age" value="25"/>
        </bean>
    </property>
</bean>
```

내부 빈 정의에는 정의된 ID 또는 이름이 필요하지 않다. 지정된 경우 컨테이너는 이러한 값을 식별자로 사용하지 않는다. 내부 빈은 항상 익명이고 항상 외부 빈에 의해 생성되기 때문에 컨테이너는 생성 시 `scope` 플래그도 무시한다. 내부 빈에 독립적으로 접근하거나 감싸고 있는 빈이 아닌 협업 빈에 내부 빈을 주입하는 것은 불가능하다.

예를 들어 싱글톤 빈에 포함된 요청 범위 내부 빈의 경우와 같이 사용자 지정 범위에서 소멸 콜백을 수신할 수 있다. 내부 빈 인스턴스의 생성은 포함하는 빈에 연결되지만 소멸 콜백을 통해 요청한 범위의 수명 주기로 변경할 수 있습니다.(오역 가능성 존재함) 이것은 일반적인 시나리오가 아니다. 내부 빈은 일반적으로 포함하는 빈의 범위를 공유한다.

### Collections

`<list/>`, `<set/>`, `<map/>` 및 `<props/>` 요소는 각각 Java `Collection` 유형 `List`, `Set`, `Map` 및 `Properties`의 속성과 인자를 설정한다. 다음 밑의 예에서는 사용 방법을 보여준다.

```xml
<bean id="moreComplexObject" class="example.ComplexObject">
    <!-- results in a setAdminEmails(java.util.Properties) call -->
    <property name="adminEmails">
        <props>
            <prop key="administrator">administrator@example.org</prop>
            <prop key="support">support@example.org</prop>
            <prop key="development">development@example.org</prop>
        </props>
    </property>
    <!-- results in a setSomeList(java.util.List) call -->
    <property name="someList">
        <list>
            <value>a list element followed by a reference</value>
            <ref bean="myDataSource" />
        </list>
    </property>
    <!-- results in a setSomeMap(java.util.Map) call -->
    <property name="someMap">
        <map>
            <entry key="an entry" value="just some string"/>
            <entry key="a ref" value-ref="myDataSource"/>
        </map>
    </property>
    <!-- results in a setSomeSet(java.util.Set) call -->
    <property name="someSet">
        <set>
            <value>just some string</value>
            <ref bean="myDataSource" />
        </set>
    </property>
</bean>
```

맵 키 또는 값 또는 set 값의 값은 다음 요소 중 하나일 수 있다.

```xml
bean | ref | idref | list | set | map | props | value | null
```

#### Collection Merging

스프링 컨테이너는 컬렉션 병합도 지원한다. 애플리케이션 개발자는 상위 `<list/>`, `<map/>`, `<set/>` 또는 `<props/>` 요소를 정의하고 하위 `<list/>`, `<map/>`, `<set/>` 또는 `<props/>` 요소가 다음의 상위 콜렉션 값을 상속하고 재정의하도록 할 수 있다. 즉, 자식 컬렉션의 값은 부모 컬렉션과 자식 컬렉션의 요소를 병합한 결과이며 자식 컬렉션 요소는 부모 컬렉션에 지정된 값을 재정의한다.

병합에 대한 이 섹션에서는 부모-자식 빈 메커니즘에 대해 설명한다. 부모 및 자식 빈 정의에 익숙하지 않은 독자는 계속하기 전에 [관련 섹션](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions) 을 읽고 싶어할 것이다.

다음 밑의 예는 컬렉션 병합을 보여준다.

```xml
<beans>
    <bean id="parent" abstract="true" class="example.ComplexObject">
        <property name="adminEmails">
            <props>
                <prop key="administrator">administrator@example.com</prop>
                <prop key="support">support@example.com</prop>
            </props>
        </property>
    </bean>
    <bean id="child" parent="parent">
        <property name="adminEmails">
            <!-- the merge is specified on the child collection definition -->
            <props merge="true">
                <prop key="sales">sales@example.com</prop>
                <prop key="support">support@example.co.uk</prop>
            </props>
        </property>
    </bean>
<beans>
```

`child` 빈 정의의 `adminEmails` 속성에 있는 `<props/>` 요소에서 `merge=true` 속성을 사용하는 것에 주목해보자. 컨테이너에 의해 `child` 빈이 확인되고 인스턴스화되면 결과 인스턴스에는 자식의 `adminEmails` 컬렉션을 부모의 `adminEmails` 컬렉션과 병합한 결과가 포함된 `adminEmails` `Properties` 컬렉션이 있다. 다음 목록은 결과를 보여준다.

```xml
administrator=administrator@example.com
sales=sales@example.com
support=support@example.co.uk
```

자식 `Properties` 컬렉션의 값 집합은 부모 `<props/>`의 모든 속성 요소를 상속받고 `support` 값에 대한 자식의 값은 부모 컬렉션의 값을 재정의한다.

이 병합 동작은 `<list/>`, `<map/>` 및 `<set/>` 컬렉션 타입에 유사하게 적용된다. `<list/>` 요소의 특정 경우에는 `List` 컬렉션 유형(즉, `ordered` 값 컬렉션의 개념)과 관련된 의미 체계가 유지된다. 부모의 값은 모든 자식 목록의 값보다 우선하게 된다. `Map`, `Set` 및 `Properties` 컬렉션 타입의 경우 순서가 없다. 따라서 컨테이너가 내부적으로 사용하는 `Map`, `Set` 및 `Properties` 구현 타입의 기초가 되는 컬렉션 타입에는 순서 지정 의미 체계가 적용되지 않는다.

#### Limitations of Collection Merging

다른 컬렉션 타입(예: `Map` 과 `List`)끼리는 병합할 수 없다. 그렇게 하려고 하면 적절한 `Exception`이 발생한다. `merge` 속성은 상속된 child 정의에서 지정해야 합니다. parent 컬렉션 정의에 `merge` 속성을 지정하는 것은 불필요하며 원하는 병합이 되지 않는다.

#### Strongly-typed collection

Java 5에 제네릭 타입이 도입되면서 강력한 타입의 컬렉션을 사용할 수 있다. 즉, (예를 들어) `String` 요소만 포함할 수 있도록 Collection 타입을 선언할 수 있다. 스프링을 사용하여 강력한 타입의 `Collection`을 빈에 의존성 주입하는 경우 강력한 타입의 `Collection` 인스턴스의 요소가 `Collection`에 추가되기 전에 적절한 타입으로 변환되도록 스프링의 타입 변환 지원을 활용할 수 있다. 다음 밑의 예제는 Java 클래스 및 빈 정의는 어떻게 하는지 보여준다.

```java
public class SomeClass {

        private Map<String, Float> accounts;

        public void setAccounts(Map<String, Float> accounts) {
            this.accounts = accounts;
        }
}
```

```xml
<beans>
    <bean id="something" class="x.y.SomeClass">
        <property name="accounts">
            <map>
                <entry key="one" value="9.99"/>
                <entry key="two" value="2.75"/>
                <entry key="six" value="3.99"/>
            </map>
        </property>
    </bean>
</beans>
```

`something` 빈의 `accounts` 속성이 주입을 위해 준비되면 강력한 타입의 `Map<String, Float>` 요소 타입에 대한 제네릭 정보를 리플렉션을 통해 사용할 수 있다. 따라서 스프링의 타입 변환 인프라는 다양한 값 요소를 `Float` 유형으로 인식하고 문자열 값(`9.99`, `2.75`, `3.99`)을 실제 `Float` 유형으로 변환한다.

### Null and Empty String Values

스프링은 속성 등에 대한 빈(empty) 인자를 빈(empty) 문자열로 취급합니다. 다음 XML 기반 configuration 메타데이터 부분은 이메일 속성을 빈(empty) 문자열 값("")으로 설정한다.

```xml
<bean class="ExampleBean">
    <property name="email" value=""/>
</bean>
```

앞의 예제는 다음 밑의 Java 코드와 동일하다.

```java
exampleBean.setEmail("");
```

`<null/>` 요소는 `null` 값을 처리한다. 다음은 그 예를 보여준다.

```xml
<bean class="ExampleBean">
    <property name="email">
        <null/>
    </property>
</bean>
```

앞의 configuration은 다음 밑의 Java 코드와 동일하다.

```java
exampleBean.setEmail(null);
```

### XML Shortcut with the p-namespace

p-namespace를 사용하면 `bean` 요소의 속성(중첩된 `<property/>` 요소를 제외하고)을 사용하여 협업하는 빈의 속성 값 또는 둘 다를 설명할 수 있다.

스프링은 XML 스키마 정의를 기반으로 하는 [네임스페이스](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#xsd-schemas) 로 확장 가능한 configuration 형식을 지원한다. 이 장에서 논의하는 `bean` 설정 형식은 XML Schema 문서에 정의되어 있다. 그러나 p-namespace는 XSD(XML Schema Definition) 파일에 정의되어 있지 않고 스프링의 코어에만 존재한다.

다음 예는 동일한 결과로 확인되는 두 개의 XML 부분(첫 번째는 표준 XML 형식을 사용하고 두 번째는 p-namespace를 사용)을 보여준다.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="classic" class="com.example.ExampleBean">
        <property name="email" value="someone@somewhere.com"/>
    </bean>

    <bean name="p-namespace" class="com.example.ExampleBean"
          p:email="someone@somewhere.com"/>
</beans>
```

예제는 bean 정의에서 `email`이라는 p-namespace의 속성을 보여준다. 이것은 속성 선언을 포함하도록 스프링에 알려준다. 앞서 언급했듯이 p-namespace에는 스키마 정의가 없으므로 속성(attribute) 이름을 속성(property) 이름으로 설정할 수 있습니다.

다음 밑의 예제에는 다른 빈에 대한 참조가 있는 두 개의 빈 정의가 더 포함되어 있다.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:p="http://www.springframework.org/schema/p"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean name="john-classic" class="com.example.Person">
        <property name="name" value="John Doe"/>
        <property name="spouse" ref="jane"/>
    </bean>

    <bean name="john-modern"
          class="com.example.Person"
          p:name="John Doe"
          p:spouse-ref="jane"/>

    <bean name="jane" class="com.example.Person">
        <property name="name" value="Jane Doe"/>
    </bean>
</beans>
```

이 예는 p-namespace를 사용하는 속성 값을 포함할 뿐만 아니라 속성 참조를 선언하는 특수 형식을 사용한다. 첫 번째 bean 정의는 bean `john`에서 bean `jane`으로의 참조를 생성하기 위해 `<property name="spouse" ref="jane"/>`를 사용하는 반면, 두 번째 bean 정의는 똑같은 행위를 위해 `p:spouse-ref="jane"`을 수행할 속성으로 사용한다. 이 경우 `spouse`는 속성명이고 `-ref` 부분은 이것이 스트레이트 값이 아니라 다른 빈에 대한 참조임을 나타낸다.

> 💡 p-namespace는 표준 XML 형식만큼 유연하지 않다. 예를 들어 속성 참조 선언 형식은 `Ref`로 끝나는 속성과 충돌하지만 표준 XML 형식은 그렇지 않는다. 세 가지 접근 방식을 동시에 사용하는 XML 문서를 생성하지 않도록 접근 방식을 신중하게 선택하고 이를 팀 구성원에게 전달하는 것이 좋다.

### XML Shortcut with the c-namespace

[p-namespace가 있는 XML Shortcut](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-p-namespace) 과 유사하게 스프링 3.1에 도입된 c-namespace는 중첩된 `constructor-arg` 요소가 아닌 생성자 인자를 구성하기 위한 인라인 속성을 허용한다.

다음 예제에서는 `c:` 네임스페이스를 사용하여 [생성자 기반 의존성 주입](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-constructor-injection) 에서와 동일한 작업을 수행한다.

```xml
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:c="http://www.springframework.org/schema/c"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="beanTwo" class="x.y.ThingTwo"/>
    <bean id="beanThree" class="x.y.ThingThree"/>

    <!-- traditional declaration with optional argument names -->
    <bean id="beanOne" class="x.y.ThingOne">
        <constructor-arg name="thingTwo" ref="beanTwo"/>
        <constructor-arg name="thingThree" ref="beanThree"/>
        <constructor-arg name="email" value="something@somewhere.com"/>
    </bean>

    <!-- c-namespace declaration with argument names -->
    <bean id="beanOne" class="x.y.ThingOne" c:thingTwo-ref="beanTwo"
        c:thingThree-ref="beanThree" c:email="something@somewhere.com"/>

</beans>
```

`c:` 네임스페이스는 이름으로 생성자 인자를 설정하기 위해 `p:`(bean 참조의 경우 후행 -ref)와 동일한 규칙을 사용한다. 마찬가지로 XSD 스키마(스프링 코어 내부에 존재)에 정의되어 있지 않더라도 XML 파일에 선언해야 한다.

드물게 생성자 인자 이름을 사용할 수 없는 경우(일반적으로 바이트코드가 디버깅 정보 없이 컴파일된 경우) 다음과 같이 인자 인덱스에 대한 대체를 사용할 수 있다.

```xml
<!-- c-namespace index declaration -->
<bean id="beanOne" class="x.y.ThingOne" c:_0-ref="beanTwo" c:_1-ref="beanThree"
    c:_2="something@somewhere.com"/>
```

> 💡 XML 문법으로 인해 인덱스 표기법에는 선행 _가 있어야 한다. XML 속성 이름은 숫자로 시작할 수 없기 때문이다. 해당 인덱스 표기법은 `<constructor-arg>` 요소에도 사용할 수 있지만 일반 선언 순서로 충분하기 때문에 일반적으로 사용되지 않는다.

실제로 생성자 resolution [메커니즘](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-ctor-arguments-resolution) 은 인자를 일치시키는 데 매우 효율적이므로 꼭 필요한 경우가 아니면 configuration 전체에서 이름 표기법을 사용하는 것이 좋다.

### Compound Property Names

최종 속성 이름을 제외한 경로의 모든 구성 요소가 null이 아닌 빈 속성을 설정할 때 복합 또는 중첩 속성 이름을 사용할 수 있다. 다음 빈 정의를 생각해보자.

```xml
<bean id="something" class="things.ThingOne">
    <property name="fred.bob.sammy" value="123" />
</bean>
```

`something` 빈에는 `fred` 속성이 있고, `bob` 속성에는 `sammy` 속성이 있고 최종 `sammy` 속성은 `123`의 값으로 설정된다. 이것이 동작하려면 `something`의 `fred` 속성과 `bob` 속성이 필요하다. 빈이 생성된 후에는 `fred`가 null이 아니어야 한다. 그렇지 않으면 `NullPointerException`이 발생하게 된다.

## 1.4.3. Using `depends-on`

Bean이 다른 Bean의 의존성이 있는 경우 일반적으로 하나의 Bean이 다른 Bean의 속성으로 설정됨을 의미한다. 일반적으로 XML 기반 configuration 메타데이터의 `<ref/>` 요소를 사용하여 이를 수행한다. 그러나 때로는 빈 간의 의존성이 덜 직접적인 경우가 있다. 예를 들어 데이터베이스 드라이버 등록과 같이 클래스의 정적 이니셜라이저를 트리거해야 하는 경우가 있다. `depends-on` 속성은 이 요소를 사용하는 빈이 초기화되기 전에 하나 이상의 빈이 초기화되도록 명시적으로 강제할 수 있다. 다음 밑의 예는 단일 빈에 대한 의존성을 표현하기 위해 `depends-on` 속성을 사용한다.

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager"/>
<bean id="manager" class="ManagerBean" />
```

여러 빈에 대한 의존성을 표현하려면 빈 이름 목록을 `depends-on` 속성의 값으로 제공하면 된다(쉼표, 공백 및 세미콜론은 유효한 구분 기호이다).

```xml
<bean id="beanOne" class="ExampleBean" depends-on="manager,accountDao">
    <property name="manager" ref="manager" />
</bean>

<bean id="manager" class="ManagerBean" />
<bean id="accountDao" class="x.y.jdbc.JdbcAccountDao" />
```

> `depends-on` 속성은 초기화때의 의존성과 [싱글톤](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) 빈의 경우에만 해당 소멸 시간 의존성을 지정할 수 있다. 주어진 빈과 `depends-on` 관계를 정의하는 의존된 빈은 주어진 빈 자체가 파괴되기 전에 먼저 파괴됩니다. 따라서 `depends-on` 항목은 종료 순서도 제어할 수 있다.

## 1.4.4. Lazy-initialized Beans

기본적으로 `ApplicationContext` 구현은 초기화 프로세스의 일부로 모든 [싱글톤](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) 빈을 열심히 생성하고 구성한다. 일반적으로 이러한 사전 인스턴스화는 configuration 또는 주변 환경의 오류가 몇 시간 또는 며칠 후가 아니라 즉시 발견되기 때문에 바람직하다. 이 동작이 바람직하지 않은 경우 빈 정의를 지연 초기화(lazy-initialized)로 표시하여 싱글톤 빈의 사전 인스턴스화를 방지할 수 있다. 지연 초기화 빈은 IoC 컨테이너에 시작 시가 아니라 처음 요청될 때 Bean 인스턴스를 생성하도록 지시한다.

XML에서 이 동작은 다음 밑의 예제와 같이 `<bean/>` 요소의 `lazy-init` 속성에 의해 제어된다.

```xml
<bean id="lazy" class="com.something.ExpensiveToCreateBean" lazy-init="true"/>
<bean name="not.lazy" class="com.something.AnotherBean"/>
```

앞 예제의 configuration이 `ApplicationContext`에 의해 동작될 때, `lazy` 빈은 `ApplicationContext`가 시작될 때 적극적으로 사전 인스턴스화되지 않는 반면 `not.lazy` 빈은 적극적으로 사전 인스턴스화된다.

그러나 지연 초기화 빈이 지연 초기화되지 않은 싱글톤 빈의 의존성인 경우 `ApplicationContext`는 싱글톤의 의존성을 충족해야 하므로 시작 시 지연 초기화 빈을 생성한다. 지연 초기화 빈은 지연 초기화되지 않은 싱글톤 빈에 주입된다.

다음 밑의 예제와 같이 `<beans/>` 요소의 `default-lazy-init` 속성을 사용하여 컨테이너 수준에서 초기화 지연을 제어할 수도 있다.

```xml
<beans default-lazy-init="true">
    <!-- no beans will be pre-instantiated... -->
</beans>
```

## 1.4.5. Autowiring Collaborators

스프링 컨테이너는 협력하는 빈 사이의 관계를 자동으로 연결(autowire)할 수 있다. `ApplicationContext`의 내용을 검사하여 스프링이 당신의 빈에 대해 자동으로 협력자(다른 빈)를 해결하도록 할 수 있다. Autowiring에는 다음과 같은 이점이 있다.

- Autowiring은 속성이나 생성자 인자를 지정할 필요성을 크게 줄일 수 있다. (이 장의 다른 곳에서 [논의된 빈 템플릿](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-child-bean-definitions) 과 같은 다른 메커니즘도 이와 관련하여 유의미 하다.)

- Autowiring은 오브젝트가 발전함에 따라 configuration을 업데이트할 수 있다. 예를 들어 클래스에 의존성을 추가해야 하는 경우 configuration을 수정할 필요 없이 해당 의존성이 자동으로 충족될 수 있다. 따라서 autowiring은 코드 기반이 더 안정될 때 명시적 연결로 전환하는 옵션을 무효화하지 않고 개발 중에 특히 유용할 수 있다.

XML 기반 configuration 메타데이터를 사용할 때([Dependency Injection](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-collaborators) 참조) `<bean/>` 요소의 `autowire` 속성을 사용하여 빈 정의에 대한 autowire 모드를 지정할 수 있다. autowiring 기능에는 4가지 모드가 있다. 각 빈 별로 autowiring을 지정하고 autowire할 것을 선택할 수 있다. 다음 표에서는 네 가지 autowiring를 설명한다.

#### Table 2. Autowiring modes

| Mode             | Explanation              |
| ---------------- | ------------------------ |
| `no`             | (default) No autowiring. 빈 참조는 `ref` 요소에 의해 정의되어야 한다. collaborators를 명시적으로 지정하면 더 큰 제어 및 명확성을 제공하므로 대규모 배포에는 default 설정을 변경하지 않는 것이 좋다. 어느 정도는 시스템 구조를 문서화한다. |
| `byName`         | 속성 이름으로 autowiring. 스프링은 자동 연결되어야 하는 속성과 이름이 같은 빈을 찾는다. 예를 들어 빈 정의가 이름으로 autowire로 설정되고 `master` 속성을 포함하는 경우(즉, setMaster(..) 메서드가 있음) 스프링은 `master`라는 빈 정의를 찾고 속성을 설정하는 데 사용한다. |
| `byType`         | 속성 타입의 빈이 컨테이너에 정확히 하나만 존재하는 경우 속성이 자동 연결되도록 한다. 둘 이상이 있으면 치명적인 예외가 발생하여 해당 빈에 대해 `byType` autowiring을 사용할 수 없음을 나타낸다. 일치하는 빈이 없으면 아무 일도 일어나지 않는다(속성이 설정되지 않음). |
| `constructor`    | byType과 유사하지만 생성자 인자에 적용된다. 컨테이너에 생성자 인자 타입의 빈이 정확히 하나만 없으면 치명적인 오류가 발생한다. |

`byType` 또는 `constructor` autowiring 모드를 사용하면 배열과 형식화된 컬렉션을 연결할 수 있다. 이러한 경우, 예상 타입과 일치하는 컨테이너 내의 모든 autowire 후보가 의존성을 충족하도록 제공된다. 예상 키 타입이 문자열인 경우 강력한 유형의 `Map` 인스턴스를 자동 연결할 수 있다. Autowired `Map` 인스턴스의 값은 예상 타입과 일치하는 모든 빈 인스턴스로 구성되며 `Map` 인스턴스의 키는 해당 빈 이름을 포함한다.

### Autowiring의 한계와 단점(Limitations and Disadvantages of Autowiring)

Autowiring은 프로젝트 전체에서 일관되게 사용될 때 가장 잘 작동한다. Autowiring이 일반적으로 사용되지 않는 경우 개발자가 이를 사용하여 하나 또는 두 개의 빈 정의만 연결하는 것이 혼란스러울 수 있다.

autowiring의 한계와 단점을 고려하라.

- `property` 및 `constructor-arg` 설정의 명시적 의존성은 항상 autowiring을 재정의한다. 프리미티브, `Strings` 및 `Classes`(및 이러한 단순 속성의 배열)와 같은 단순 속성을 자동 연결할 수 없다. 이 제한은 의도적으로 설계된 것이다.

- Autowiring은 명시적 wiring보다 덜 정확하다. 이전 표에서 언급했듯이 스프링은 예상치 못한 결과를 초래할 수 있는 모호한 경우를 대비하여 추측을 피하도록 주의한다. 스프링 관리 객체 간의 관계는 더 이상 명시적으로 문서화되지 않는다.

- 스프링 컨테이너에서 문서를 생성할 수 있는 도구에서 wiring 정보를 사용하지 못할 수 있다.

- 컨테이너 내의 여러 빈 정의는 자동 연결될 setter 메서드 또는 생성자 인자에 의해 지정된 타입과 일치할 수 있다. 배열, 컬렉션 또는 `Map` 인스턴스의 경우 이것이 반드시 문제가 되는 것은 아니다. 그러나 단일 값을 기대하는 의존성의 경우 이 모호성이 임의로 해결되지 않는다. 고유한 빈 정의를 사용할 수 없으면 예외가 발생한다.

후자의 시나리오에는 다음과 같은 몇 가지 옵션이 있다.

- 명시적 연결을 위해 autowiring을 포기한다.

- [다음 섹션](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-autowire-candidate) 에 설명된 대로 `autowire-candidate` 속성을 `false`로 설정하여 빈 정의에 대한  autowiring을 피한다.

- `<bean/>` 요소의 `primary` 속성을 `true`로 설정하여 단일 빈 정의를 기본 후보로 지정한다.

- [어노테이션 기반 컨테이너 Configuration](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config) 에 설명된 대로 어노테이션 기반 configuration 으로 사용할 수 있는 보다 세분화된 제어를 구현한다.

### Excluding a Bean from Autowiring

빈 단위로 autowiring에서 빈을 제외할 수 있다. 스프링의 XML 형식에서 `<bean/>` 요소의 `autowire-candidate` 속성을 `false`로 설정한다. 컨테이너는 특정 빈 정의를 autowiring 인프라에서 사용할 수 없도록 만든다([@Autowired](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-autowired-annotation) 와 같은 어노테이션 스타일 configuration 포함).

> 💡 `autowire-candidate` 속성은 타입 기반 autowiring에만 영향을 미치도록 설계되었다. 지정된 빈이 autowire 후보로 표시되지 않은 경우에도 해결되는 이름별 명시적 참조에는 영향을 미치지 않는다. 결과적으로 이름에 의한 autowiring은 이름이 일치하면 빈을 주입한다.

또한 빈 이름에 대한 패턴 일치를 기반으로 autowire 후보를 제한할 수 있다. 최상위 `<beans/>` 요소는 `default-autowire-candidates` 속성 내에서 하나 이상의 패턴을 허용한다. 예를 들어, 이름이 `Repository`로 끝나는 빈으로 autowire 후보 상태를 제한하려면 `*Repository` 값을 제공하라. 여러 패턴을 제공하려면 쉼표로 구분된 목록으로 정의하라. 빈 정의의 `autowire-candidate` 속성에 대한 명시적 `true` 또는 `false` 값이 항상 우선한다. 이러한 빈의 경우 패턴 일치 규칙이 적용되지 않는다.

이러한 기술은 autowiring에 의해 다른 빈에 주입되고 싶지 않은 빈에 유용하다. 제외된 빈 자체를 autowiring을 사용하여 구성할 수 없다는 의미는 아니다. 대신, 빈 자체는 다른 빈을 autowiring하기 위한 후보가 아니게 된다.

## 1.4.6. Method Injection

대부분의 애플리케이션 시나리오에서 컨테이너에 있는 대부분의 빈은 [싱글톤](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) 이다. 싱글톤 빈이 다른 싱글톤 빈과 협력해야 하거나 싱글톤이 아닌 빈이 다른 싱글톤이 아닌 빈과 협력해야 하는 경우 일반적으로 한 빈을 다른 빈의 속성으로 정의하여 의존성을 처리한다. 문제는 빈 수명 주기가 다를 때 발생한다. 싱글톤 빈 A가 싱글톤이 아닌(프로토타입) 빈 B를 사용할 필요가 있다고 가정하자. 컨테이너가 싱글톤 빈 A를 한 번만 생성하므로 속성을 설정할 수 있는 기회는 한 번뿐일 것이다. 컨테이너는 필요할 때마다 빈 B의 새 인스턴스를 빈 A에 제공할 수 없다.

해결책은 제어 역전을 방지하는 것이다. `ApplicationContextAware` 인터페이스를 구현함으로써 [빈 A가 컨테이너를 인식하도록](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-aware) 할 수 있고 [컨테이너에 `getBean("B")` 호출을 통해](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-client) 빈 A가 필요할 때마다 (일반적으로 new로) 빈 B 인스턴스를 요청한다. 다음 예에서는 이러한 접근 방식을 보여준다.

```java
// a class that uses a stateful Command-style class to perform some processing
package fiona.apple;

// Spring-API imports
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

public class CommandManager implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    public Object process(Map commandState) {
        // grab a new instance of the appropriate Command
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    protected Command createCommand() {
        // notice the Spring API dependency!
        return this.applicationContext.getBean("command", Command.class);
    }

    public void setApplicationContext(
            ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }
}
```

비즈니스 코드가 스프링 프레임워크를 인식하고 연결하기 때문에 앞의 것은 바람직하지는 않다. Spring IoC 컨테이너의 다소 고급 기능인 메소드 주입을 사용하면 이 사용 사례를 깔끔하게 처리할 수 있다.

> 이 [블로그](https://spring.io/blog/2004/08/06/method-injection/) 에서 메서드 주입의 동기에 대해 자세히 읽을 수 있다.

### Lookup Method Injection

Lookup Method Injection은 컨테이너에 관리되는 빈의 메소드를 재정의(override)하고 컨테이너의 다른 명명된 빈에 대한 조회 결과를 리턴하는 컨테이너의 기능이다. 조회에는 일반적으로 [이전 섹션](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-method-injection) 에서 설명한 시나리오와 같이 프로토타입 빈이 포함된다. 스프링 프레임워크는 CGLIB(Code Generation Library) 라이브러리에서 바이트코드 생성을 사용하여 이 메서드 주입을 구현하여 메서드를 재정의하는 하위 클래스를 동적으로 생성한다.

> 이 동적 서브클래싱이 작동하려면 Spring Bean 컨테이너의 서브클래스가 `final`일 수 없고 재정의해야 하는 메소드도 `final`일 수 없다.
>
> `abstract` 메서드가 있는 클래스를 단위 테스트하려면 하위 클래스를 만들고 `abstract` 메서드의 스텁 구현을 제공해야 한다.
>
> 구체적인 클래스를 선택해야 하는 컴포넌트 스캔에도 구체적인 메소드가 필요하다.
> 
> 또 다른 주요 제한 사항은 lookup method가 팩토리 메서드, 특히 configuration 클래스의 `@Bean` 메서드와 함께 작동하지 않는다는 것이다. 이 경우 컨테이너는 인스턴스 생성을 담당하지 않으므로 runtime-generated 하위 클래스를 즉석에서 생성할 수 없다.

이전 코드 부분의 `CommandManager` 클래스의 경우 스프링 컨테이너는 createCommand() 메서드의 구현을 동적으로 재정의(override)한다. 아래 재작업된 예제에서 볼 수 있듯이 `CommandManager` 클래스에는 스프링 의존성이 없다.

```java
package fiona.apple;

// no more Spring imports!

public abstract class CommandManager {

    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

주입할 메서드를 포함하는 클라이언트 클래스((이 경우 `CommandManager`)에서 주입할 메서드에는 다음 형식의 서명이 필요하다.

```
<public|protected> [abstract] <return-type> theMethodName(인수 없음);
```

메서드가 `abstract`면 동적으로 생성된 하위 클래스가 메서드를 구현한다. 그렇지 않으면 동적으로 생성된 하위 클래스가 원래 클래스에 정의된 구체적인 메서드를 재정의(override)한다. 다음 예를 살펴보자.

```xml
<!-- a stateful bean deployed as a prototype (non-singleton) -->
<bean id="myCommand" class="fiona.apple.AsyncCommand" scope="prototype">
    <!-- inject dependencies here as required -->
</bean>

<!-- commandProcessor uses statefulCommandHelper -->
<bean id="commandManager" class="fiona.apple.CommandManager">
    <lookup-method name="createCommand" bean="myCommand"/>
</bean>
```

`commandManager`로 식별된 빈은 `myCommand` 빈의 새 인스턴스가 필요할 때마다 자체 `createCommand()` 메서드를 호출한다. `myCommand` 빈이 실제로 필요한 경우 해당 빈을 프로토타입으로 배포할 때 주의해야 한다. [싱글톤](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-singleton) 인 경우 매번 동일한 `myCommand` 빈 인스턴스가 반환된다.

또는 어노테이션 기반 component 모델 내에서 다음 예제와 같이 `@Lookup` 어노테이션을 통해 lookup method를 선언할 수 있다.

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup("myCommand")
    protected abstract Command createCommand();
}
```

또는 보다 관용적으로 lookup method의 선언된 리턴 타입에 대해 결정되는 대상 빈에 의존할 수 있다.

```java
public abstract class CommandManager {

    public Object process(Object commandState) {
        Command command = createCommand();
        command.setState(commandState);
        return command.execute();
    }

    @Lookup
    protected abstract Command createCommand();
}
```

추상 클래스가 기본적으로 무시되는 스프링의 구성 요소(component) 스캐닝 규칙과 호환되도록 하려면 일반적으로 구체적인 스텁 구현으로 어노테이션이 달린 lookup method를 선언해야 한다. 이 제한은 명시적으로 등록되거나 명시적으로 가져온 빈 클래스에는 적용되지 않는다.

> 💡 범위가 다른 대상 빈에 액세스하는 또 다른 방법은 `ObjectFactory`/`Provider` 주입 지점이다. [의존성에서 범위 지정 빈](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes-other-injection) 을 참조.
> 
> `ServiceLocatorFactoryBean`(`org.springframework.beans.factory.config` 패키지에 있음)이 유용할 수도 있다.

### Arbitrary Method Replacement(임의의 메소드 대체)

lookup method 주입보다 덜 유용한 메서드 주입 형식은 관리되는 빈의 임의 메서드를 다른 메서드 구현으로 대체하는 기능이다. 이 기능이 실제로 필요할 때까지 이 섹션의 나머지 부분은 건너 뛰어도 된다.

XML 기반 configuration 메타데이터를 사용하면 배포된 빈에 대해 기존 메소드 구현을 대체하기 위해 `replacement-method` 요소를 사용할 수 있다. 재정의(override)하려는 `computeValue`라는 메서드가 있는 다음 클래스를 살펴보자.

```java
public class MyValueCalculator {

    public String computeValue(String input) {
        // some real code...
    }

    // some other methods...
}
```

`org.springframework.beans.factory.support.MethodReplacer` 인터페이스를 구현하는 클래스는 다음 예제와 같이 새 메서드 정의를 제공한다.

```java
/**
 * meant to be used to override the existing computeValue(String)
 * implementation in MyValueCalculator
 */
public class ReplacementComputeValue implements MethodReplacer {

    public Object reimplement(Object o, Method m, Object[] args) throws Throwable {
        // get the input value, work with it, and return a computed result
        String input = (String) args[0];
        ...
        return ...;
    }
}
```

원래 클래스를 배포하고 메서드 재정의(override)를 지정하는 빈 정의는 다음 예제와 유사하다.

```xml
<bean id="myValueCalculator" class="x.y.z.MyValueCalculator">
    <!-- arbitrary method replacement -->
    <replaced-method name="computeValue" replacer="replacementComputeValue">
        <arg-type>String</arg-type>
    </replaced-method>
</bean>

<bean id="replacementComputeValue" class="a.b.c.ReplacementComputeValue"/>
```

재정의(override)되는 메서드의 메서드 서명(signature)을 나타내기 위해 `<replaced-method/>` 요소 내에서 하나 이상의 `<arg-type/>` 요소를 사용할 수 있다. 인자에 대한 서명(signature)은 메서드가 오버로드되고 클래스 내에 여러 변형이 있는 경우에만 필요하다. 편의상 인자의 타입 문자열은 정규화된 타입 이름의 하위 문자열일 수 있다. 예를 들어 다음은 모두 `java.lang.String`과 일치한다.

```
java.lang.String
String
Str
```

인자의 수는 각 가능한 선택을 구별하기에 충분하기 때문에 이 방법을 사용하면 인자 타입과 일치하는 가장 짧은 문자열만 입력할 수 있으므로 많은 입력을 줄일 수 있다.
