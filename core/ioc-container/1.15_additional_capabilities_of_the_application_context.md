# 1.15. Additional Capabilities of the ApplicationContext

> [1.15. Additional Capabilities of the ApplicationContext](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#context-introduction) ì±•í„°ë¥¼ ìš”ì•½í•œ ë‚´ìš©ì…ë‹ˆë‹¤.

ì´ì „ [ì±•í„°](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans)ì—ì„œ ì†Œê°œí–ˆë“¯ì´, `org.springframework.beans.factory` íŒ¨í‚¤ì§€ëŠ” ë¹ˆë“¤ì„ ê´€ë¦¬í•˜ê³ , ì¡°ì‘í•˜ëŠ” ê¸°ë³¸ ê¸°ëŠ¥ë“¤ì„ í”„ë¡œê·¸ë˜ë° ë°©ì‹ê³¼ í•¨ê»˜ ì œê³µí•´ì¤ë‹ˆë‹¤. `org.springframework.context` íŒ¨í‚¤ì§€ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ í”„ë ˆì„ì›Œí¬ ê´€ì ì˜ ì¶”ê°€ ê¸°ëŠ¥ë“¤ì„ ì œê³µí•˜ê¸° ìœ„í•´ì„œ BeanFactory ì¸í„°í˜ì´ìŠ¤ë¥¼ í™•ì¥í•œ ApplicationContextì™€ ê¸°íƒ€ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ë§ì€ ì‚¬ëŒë“¤ì€ ApplicationContextë¥¼ í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ìƒì„±í•˜ì§€ ì•Šê³ , Java EE ì›¹ ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ ì‹œì‘ ë‹¨ê³„ì—ì„œ ApplicationContextë¥¼ ìë™ìœ¼ë¡œ êµ¬ì„±í•´ì£¼ëŠ” ContextLoaderì™€ ê°™ì€ ì§€ì› í´ë˜ìŠ¤ë¥¼ ì´ìš©í•œ ì„ ì–¸ì ì¸ ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•©ë‹ˆë‹¤.


To enhance BeanFactory functionality in a more framework-oriented style, the context package also provides the following functionality:

Access to messages in i18n-style, through the MessageSource interface.

Access to resources, such as URLs and files, through the ResourceLoader interface.

Event publication, namely to beans that implement the ApplicationListener interface, through the use of the ApplicationEventPublisher interface.

Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such as the web layer of an application, through the HierarchicalBeanFactory interface.

í”„ë ˆì„ì›Œí¬ ê´€ì ì—ì„œ BeanFactory ê¸°ëŠ¥ì„ í–¥ìƒì‹œí‚¤ê¸° ìœ„í•´ì„œ, context íŒ¨í‚¤ì§€ëŠ” ë‹¤ìŒ ê¸°ëŠ¥ë“¤ì„ ì œê³µí•©ë‹ˆë‹¤:

* `MessageSource` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë‹¤êµ­ì–´ ë©”ì„¸ì§€ ê´€ë¦¬ë¥¼ ë„ì™€ì¤ë‹ˆë‹¤.
* `ResourceLoader`ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ì„œ URLì´ë‚˜ íŒŒì¼ì— ê´€ë¦¬ë¥¼ ë„ì™€ì¤ë‹ˆë‹¤.
* `ApplicationEventPublisher` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ì„œ, `ApplicationListener` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ë¹ˆ ëŒ€ìƒìœ¼ë¡œ ì´ë²¤íŠ¸ ê²Œì‹œë¥¼ ì œê³µí•©ë‹ˆë‹¤.
*  `HierarchicalBeanFactory` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ì„œ, ì–´í”Œë¦¬ì¼€ì´ì…˜ ì›¹ ê³„ì¸µì²˜ëŸ¼, í•œ ê³„ì¸µì— ì§‘ì¤‘í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ë‹¤ì¤‘ ì»¨í…ìŠ¤íŠ¸ë“¤ì„ êµ¬ì¡°ì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


## 1.15.1. Internationalization using MessageSource


`ApplicationContext` ì¸í„°í˜ì´ìŠ¤ëŠ” `MessageSource` ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì†í•˜ê³  ìˆìœ¼ë¯€ë¡œ, ë‹¤êµ­ì–´ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤. ìŠ¤í”„ë§ì€ ë©”ì„¸ì§€ë¥¼ ê³„ì¸µì ìœ¼ë¡œ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” `HierarchicalMessageSource` ì¸í„°í˜ì´ìŠ¤ë„ ì œê³µí•©ë‹ˆë‹¤. ì´ ì¸í„°í˜ì´ìŠ¤ë“¤ì€ ìŠ¤í”„ë§ì˜ ë©”ì„¸ì§€ë¥¼ ê´€ë¦¬í•˜ëŠ” ê¸°ë°˜ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ ì¸í„°í˜ì´ìŠ¤ ë©”ì†Œë“œëŠ” ë‹¤ìŒì„ í¬í•¨í•©ë‹ˆë‹¤:

* `String getMessage(String code, Object[] args, String default, Locale loc)`: MessageSourceë¡œë¶€í„° ë©”ì„¸ì§€ë¥¼ ì°¸ì¡°í•©ë‹ˆë‹¤. ë§Œì•½ ì§€ì •ëœ ë‹¤êµ­ì–´ ë©”ì„¸ì§€ê°€ ì—†ë‹¤ë©´, ê¸°ë³¸ ë©”ì„¸ì§€ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤. `args` ì¸ìë“¤ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ MessageFormatì„ í†µí•´ì„œ ê°’ìœ¼ë¡œ ëŒ€ì²´ë©ë‹ˆë‹¤.  

* `String getMessage(String code, Object[] args, Locale loc)`: ìœ„ ë©”ì†Œë“œì™€ ê°™ì§€ë§Œ, ê¸°ë³¸ ë©”ì„¸ì§€ë¥¼ ì œê³µí•˜ì§€ ì•Šì•„ë„ ë©ë‹ˆë‹¤. ì§€ì›í•˜ì§€ ì•ŠëŠ” ë‹¤êµ­ì–´ë¼ë©´ `NoSuchMessageException` ì˜ˆì™¸ë¥¼ ë˜ì§‘ë‹ˆë‹¤.

* `String getMessage(MessageSourceResolvable resolvable, Locale locale)`: ìœ„ì—ì„œ ì‚¬ìš©ëœ ëª¨ë“  ì¸ìˆ˜ë“¤ì´ MessageSourceResolvable í´ë˜ìŠ¤ë¡œ ê°ì‹¸ì§„ í˜•íƒœì…ë‹ˆë‹¤.


`ApplicationContext`ê°€ ë¡œë“œê°€ ë˜ë©´, ì»¨í…ìŠ¤íŠ¸ ë‚´ MessageSource ë¹ˆì„ ìë™ìœ¼ë¡œ ì°¾ìŠµë‹ˆë‹¤. ë¹ˆ ì´ë¦„ì€ `messageSource`ì—¬ì•¼ í•©ë‹ˆë‹¤. ë§Œì•½ ë©”ì„¸ì§€ì†ŒìŠ¤ ë¹ˆì„ ì°¾ì•˜ë‹¤ë©´, ìœ„ ë©”ì†Œë“œë“¤ì€ í•´ë‹¹ ë¹ˆì—ê²Œ ìœ„ì„ë©ë‹ˆë‹¤. ë§Œì•½ ì°¾ì§€ ëª»í–ˆë‹¤ë©´, ë¶€ëª¨ ì»¨í…ìŠ¤íŠ¸ì— ë©”ì„¸ì§€ì†ŒìŠ¤ ë¹ˆì„ ì°¾ìŠµë‹ˆë‹¤. ë¶€ëª¨ì—ê²Œì„œ ë©”ì„¸ì§€ì†ŒìŠ¤ ë¹ˆì„ ì°¾ì•˜ë‹¤ë©´, ë©”ì„¸ì§€ë¥¼ í•´ë‹¹ ë¹ˆìœ¼ë¡œë¶€í„° ê°€ì ¸ì˜µë‹ˆë‹¤. ë§Œì•½ ë©”ì„¸ì§€ ì†ŒìŠ¤ ë¹ˆì„ ì°¾ì§€ ëª»í–ˆë‹¤ë©´, ìœ„ì˜ ë©”ì†Œë“œ í˜¸ì¶œì„ ë‹´ë‹¹í•  ë¹ˆ `DelegatingMessageSource`ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.

ìŠ¤í”„ë§ì€ `ResourceBundleMessageSource`, `ReloadableResourceBundleMessageSource`, `StaticMessageSource` 3ê°€ì§€ MessageSource ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„ì²´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ êµ¬í˜„ì²´ë“¤ì€ ê³„ì¸µì ìœ¼ë¡œ ê´€ë¦¬ê°€ ê°€ëŠ¥í•˜ë„ë¡ `HierarchicalMessageSource` ì¸í„°í˜ì´ìŠ¤ë¥¼ ëª¨ë‘ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤. `StaticMessageSource`ëŠ” í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ë©”ì„¸ì§€ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´ì„œ ê°„í˜¹ ì‚¬ìš©ë©ë‹ˆë‹¤. ì•„ë˜ëŠ” `ResourceBundleMessageSource` ì˜ˆì œ ì…ë‹ˆë‹¤:

```xml
<beans>
    <bean id="messageSource"
            class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basenames">
            <list>
                <value>format</value>
                <value>exceptions</value>
                <value>windows</value>
            </list>
        </property>
    </bean>
</beans>
```

ì˜ˆì œì—ì„œëŠ” 3ê°€ì§€ `format`, `exceptions`, `windows` ì´ë¦„ì˜ ë¦¬ì†ŒìŠ¤ ë²ˆë“¤ì„ ê°€ì •í•©ë‹ˆë‹¤. ë©”ì„¸ì§€ë¥¼ ì°¸ì¡°í•˜ê¸° ìœ„í•´ì„œ ë¦¬ì†ŒìŠ¤ë²ˆë“¤ ê°ì²´ë¥¼ ì´ìš©í•´ì„œ JDK í‘œì¤€ë°©ì‹ìœ¼ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤. ì˜ˆì œë¥¼ ìœ„í•´, ì•„ë˜ì˜ 2 ë²ˆë“¤ íŒŒì¼ì˜ ë‚´ìš©ì„ ê°€ì •í•©ë‹ˆë‹¤:

```text
    # in format.properties
    message=Alligators rock!
```

```text
    # in exceptions.properties
    argument.required=The {0} argument is required.
```

ì•„ë˜ëŠ” `MessageSource` ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ëŠ” í”„ë¡œê·¸ë¨ ì˜ˆì œì…ë‹ˆë‹¤. ëª¨ë“  `ApplicationContext`ëŠ” `MessageSource` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ê³  ìˆê¸° ë•Œë¬¸ì— ë©”ì„¸ì§€ì†ŒìŠ¤ë¡œ ìºìŠ¤íŒ…ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```java
public static void main(String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("message", null, "Default", Locale.ENGLISH);
    System.out.println(message);
}
```

ìœ„ í”„ë¡œê·¸ë¨ì˜ ê²°ê³¼ëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤:

```text
Alligators rock!
```

ìš”ì•½í•˜ìë©´ `MessageSource`ëŠ” í´ë˜ìŠ¤íŒ¨ìŠ¤ ë£¨íŠ¸ì— ìœ„ì¹˜í•œ beans.xml íŒŒì¼ì— ì •ì˜ë˜ì–´ ìˆìœ¼ë©°, `messageSource` ë¹ˆì€ `basenames` ì†ì„±ì„ í†µí•´ì„œ ì—¬ëŸ¬ ë¦¬ì†ŒìŠ¤ ë²ˆë“¤ì„ ì°¸ì¡°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. basenames ì†ì„±ì— ì „ë‹¬ëœ 3 íŒŒì¼ë“¤ì€ í´ë˜ìŠ¤íŒ¨ìŠ¤ rootì— ìœ„ì¹˜í•´ ìˆìœ¼ë©°, ê° íŒŒì¼ì˜ ì´ë¦„ì€ `format.properties`,`exceptions.properties`,`windows.properties`ì…ë‹ˆë‹¤.

ë‹¤ìŒ ì˜ˆì œëŠ” ë©”ì†Œë“œ lookupì— ì „ë‹¬ëœ ì¸ìë“¤ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. ì¸ìë“¤ì€ ë¬¸ìì—´ë¡œ ìºìŠ¤íŒ…ë˜ì–´, lookup ë©”ì„¸ì§€ placeholdersì— ì£¼ì…ë©ë‹ˆë‹¤.

```xml
<beans>

    <!-- this MessageSource is being used in a web application -->
    <bean id="messageSource" class="org.springframework.context.support.ResourceBundleMessageSource">
        <property name="basename" value="exceptions"/>
    </bean>

    <!-- lets inject the above MessageSource into this POJO -->
    <bean id="example" class="com.something.Example">
        <property name="messages" ref="messageSource"/>
    </bean>

</beans>
```

```java
public class Example {

    private MessageSource messages;

    public void setMessages(MessageSource messages) {
        this.messages = messages;
    }

    public void execute() {
        String message = this.messages.getMessage("argument.required",
            new Object [] {"userDao"}, "Required", Locale.ENGLISH);
        System.out.println(message);
    }
}
```

ìœ„ ì˜ˆì œì˜ ê²°ê³¼ëŠ” `The userDao argument is required.` ì…ë‹ˆë‹¤.

ìŠ¤í”„ë§ì˜ ë‹¤ì–‘í•œ `MessageSource` êµ¬í˜„ì²´ë“¤ì€ í‘œì¤€ JDK ë¦¬ì†ŒìŠ¤ë²ˆë“¤ì˜ locale ì°¸ì¡°ë°©ì‹ê³¼ fallback ë°©ì‹ì„ ë”°ë¦…ë‹ˆë‹¤. ì¦‰, ìœ„ ì˜ˆì œì—ì„œ ì˜êµ­(en-GB) ë©”ì„¸ì§€ë¥¼ ì§€ì›í•˜ê¸° ìœ„í•´ì„œëŠ” `format_en_GB.properties`, `exceptions_en_GB.properties`, `windows_en_GB.properties` íŒŒì¼ì„ ì œê³µí•´ì•¼í•©ë‹ˆë‹¤.

íŠ¹íˆ, ë‹¤êµ­ì–´ëŠ” ì–´í”Œë¦¬ì¼€ì´ì…˜ì˜ í™˜ê²½ë³€ìˆ˜ì— ì˜í•´ ê´€ë¦¬ë©ë‹ˆë‹¤. ë‹¤ìŒì€ ì˜êµ­ ë©”ì„¸ì§€ë¥¼ ì§ì ‘ ì§€ì •í•œ ì˜ˆì œì…ë‹ˆë‹¤.

```text
# in exceptions_en_GB.properties
argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.
```

```java
public static void main(final String[] args) {
    MessageSource resources = new ClassPathXmlApplicationContext("beans.xml");
    String message = resources.getMessage("argument.required",
        new Object [] {"userDao"}, "Required", Locale.UK);
    System.out.println(message);
}
```

```text
Ebagum lad, the 'userDao' argument is required, I say, required.
```

`MessageSourceAware`ì¸í„°í˜ì´ìŠ¤ êµ¬í˜„í•œ ë¹ˆë“¤ì€, ì»¨í…ìŠ¤íŠ¸ ë‚´ ë©”ì„¸ì§€ì†ŒìŠ¤ë¥¼ ë¹ˆì´ ìƒì„±ë ë•Œ ì£¼ì…ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

{% hint style="success" %}

#### ğŸ’¡ 

ìŠ¤í”„ë§ì˜ `MessageSource`ëŠ” ìë°”ì˜ ë¦¬ì†ŒìŠ¤ ë²ˆë“¤ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ê¸° ë•Œë¬¸ì—, ê°™ì€ íŒŒì¼ëª…ì„ ê°€ì§„ ë²ˆë“¤ì€ mergeí•˜ì§€ ì•Šê³ , ì²˜ìŒ ë°œê²¬í•œ ë¦¬ì†ŒìŠ¤ë§Œì„ ì‚¬ìš©í•˜ê³  ë‚˜ë¨¸ì§€ëŠ” ë¬´ì‹œí•©ë‹ˆë‹¤.

{% endhint %}


{% hint style="success" %}

#### ğŸ’¡ 

ìŠ¤í”„ë§ì€ `ResourceBundleMessageSource`ê³¼ í•¨ê»˜ `ReloadableResourceBundleMessageSource` í´ë˜ìŠ¤ë„ ì œê³µí•©ë‹ˆë‹¤. ì´ í´ë˜ìŠ¤ëŠ” ë™ì¼í•œ ë¦¬ì†ŒìŠ¤ íŒŒì¼ í¬ë§·ë“¤ì„ ì§€ì›í•˜ì§€ë§Œ í‘œì¤€ JDK ê¸°ë°˜ì˜ `ResourceBundleMessageSource` êµ¬í˜„ì²´ë³´ë‹¤ ì¢€ ë” ìœ ì—°í•©ë‹ˆë‹¤. íŠ¹íˆ Spring ë¦¬ì†ŒìŠ¤ ìœ„ì¹˜(í´ë˜ìŠ¤ ê²½ë¡œë¿ë§Œ ì•„ë‹ˆë¼)ì—ì„œ íŒŒì¼ì„ ì½ì„ ìˆ˜ ìˆìœ¼ë©° ë²ˆë“¤ ì†ì„± íŒŒì¼ì˜ hot reloading(ìºì‹±)ì„ ì§€ì›í•©ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [ReloadableResourceBundleMessageSource](https://docs.spring.io/spring-framework/docs/5.3.23/javadoc-api/org/springframework/context/support/ReloadableResourceBundleMessageSource.html) javadocì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤.

{% endhint %}

## 1.15.2. Standard and Custom Events

`ApplicationEvent`ì™€ `ApplicationListener` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ì„œ ì»¨í…ìŠ¤íŠ¸ ë‚´ ì´ë²¤íŠ¸ë¥¼ ê´€ë¦¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë§Œì•½ ë¹ˆì´ `ApplicationListener` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í–ˆë‹¤ë©´, `ApplicationEvent` ì»¨í…ìŠ¤íŠ¸ ì•ˆì—ì„œ ì´ë²¤íŠ¸ê°€ ë°œìƒí• ë•Œë§ˆë‹¤, ì•Œë¦¼ì„ ë°›ìŠµë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ Observer ë””ìì¸ íŒ¨í„´ì„ ë”°ë¦…ë‹ˆë‹¤.


{% hint style="success" %}

#### ğŸ’¡ 

ìŠ¤í”„ë§ 4.2ë¶€í„°, ì´ë²¤íŠ¸ ê´€ë ¨ ê¸°ëŠ¥ë“¤ì´ ì–´ë…¸í…Œì´ì…˜ ë°©ì‹ìœ¼ë¡œ ì œê³µë˜ê³ , ì´ë²¤íŠ¸ ë°ì´í„° í˜•ì‹ì˜ ì œí•œì´ ì—†ì–´ì§€ë©´ì„œ(ì¦‰, ì´ë²¤íŠ¸ ì „ë‹¬ ê°ì²´ê°€ `ApplicationEvent`ì„ ìƒì†í•  í•„ìš”ê°€ ì—†ì–´ì§.) í¸ì˜ì„±ì„ í¬ê²Œ í–¥ìƒ ì‹œì¼°ìŠµë‹ˆë‹¤. ì´ë²¤íŠ¸ ê°ì²´ê°€ ë°œìƒí•  ë•Œ, ìŠ¤í”„ë§ì´ ê°ì²´ë¥¼ ê°ì‹¸ì£¼ê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

{% endhint %}

ë‹¤ìŒ í‘œëŠ” ìŠ¤í”„ë§ì—ì„œ ì œê³µí•˜ëŠ” í‘œì¤€ ì´ë²¤íŠ¸ì…ë‹ˆë‹¤:

| ì´ë²¤íŠ¸ | ì„¤ëª… |
|--|--|
|ContextRefreshedEvent|`ApplicationContext` ê°€ ì´ˆê¸°í™”ë˜ê±°ë‚˜ ìƒˆë¡œê³ ì¹¨( `ConfigurableApplicationContext` ì¸í„°í˜ì´ìŠ¤ì˜ refresh() ë©”ì†Œë“œ) ë ë•Œë§ˆë‹¤ ì´ë²¤íŠ¸ê°€ ë°œìƒí•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ "ì´ˆê¸°í™”" ì‹œì ì€ ëª¨ë“  ë¹ˆë“¤ì´ ë¡œë“œë˜ê³ , í›„ì²˜ë¦¬ê¸° ë¹ˆë“¤ì´ ë¡œë“œë˜ì–´ í™œì„±í™” ìƒíƒœì´ë©°, ì‹±ê¸€í†¤ ê°ì²´ë“¤ì˜ ì „ì²˜ë¦¬ê°€ ì™„ë£Œë˜ì„œ `ApplicationContext` ê°ì²´ê°€ ì‚¬ìš©ì¤€ë¹„ê°€ ì™„ë£Œëœ ì‹œì ì…ë‹ˆë‹¤. ì»¨í…ìŠ¤íŠ¸ê°€ ì¢…ë£Œë˜ì§€ ì•ŠëŠ” ì´ìƒ, ì»¨í…ìŠ¤íŠ¸ê°€ hot refreshë¥¼ ì§€ì›í•œë‹¤ë©´ ìƒˆë¡œê³ ì¹¨ ì´ë²¤íŠ¸ëŠ” ì—¬ëŸ¬ë²ˆ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ `XmlWebApplicationContext`ëŠ” hot refreshë¥¼ ì§€ì›í•˜ì§€ë§Œ `GenericApplicationContext`ëŠ” ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.|
|ContextStartedEvent|`ConfigurableApplicationContext`ì˜ start() ë©”ì†Œë“œë¥¼ í†µí•´ ì»¨í…ìŠ¤íŠ¸ê°€ ì‹œì‘ë˜ì—ˆì„ ë•Œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ì‹œì‘ ì‹œì ì€ ëª¨ë“  ë¼ì´í”„ì‚¬ì´í´ ë¹ˆë“¤ì´ ì‹œì‘ ì‹œê·¸ë„ì„ ì „ë‹¬ë°›ì€ ì‹œì ì…ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ, ì´ ì‹ í˜¸ëŠ” ë¹ˆë“¤ì„ ì¤‘ì§€í•œ ì´í›„ì— ì¬ì‹œì‘í•˜ê¸° ìœ„í•´ì„œ ì‚¬ìš©ë˜ë‚˜, ìë™ìœ¼ë¡œ ì¬ì‹œì‘í•˜ë„ë¡ ì„¤ì •ë˜ì§€ ì•Šì€ ì»´í¬ë„ŒíŠ¸ë“¤ì„ ì‹œì‘í•˜ê¸° ìœ„í•´ì„œë„ ì‚¬ìš©ë©ë‹ˆë‹¤.( ì˜ˆë¥¼ ë“¤ì–´, ì´ˆê¸°í™” ë‹¨ê³„ì— ì‹œì‘ë˜ì§€ ì•Šì€ ì»´í¬ë„ŒíŠ¸)|
|ContextStoppedEvent|`ConfigurableApplicationContext`ì˜ stop() ë©”ì†Œë“œë¥¼ í†µí•´ ì»¨í…ìŠ¤íŠ¸ê°€ ì •ì§€ë˜ì—ˆì„ ë•Œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•©ë‹ˆë‹¤. ì •ì§€ëœ ì‹œì ì€ ëª¨ë“  ë¼ì´í”„ì‚¬ì´í´ ë¹ˆë“¤ì´ ì¤‘ì§€ ì‹ í˜¸ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ë°›ì€ ì‹œì ì…ë‹ˆë‹¤. ì¤‘ì§€ëœ ì»¨í…ìŠ¤íŠ¸ëŠ” start() ë©”ì†Œë“œë¥¼ í†µí•´ ì¬ì‹œì‘ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. |
|ContextClosedEvent | `ConfigurableApplicationContext`ì˜ close() ë©”ì†Œë“œ í˜¹ì€ JVM ì¢…ë£Œ hookì— ì˜í•´ì„œ ì»¨í…ìŠ¤íŠ¸ê°€ ì¢…ë£Œë˜ì—ˆì„ ë•Œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•©ë‹ˆë‹¤. ì¢…ë£Œ ì‹œì ì€ ëª¨ë“  ì‹±ê¸€í†¤ ë¹ˆë“¤ì´ destroyed ëœ ì‹œì ì…ë‹ˆë‹¤. ì»¨í…ìŠ¤íŠ¸ê°€ ì¢…ë£Œëœ ì´í›„ì—ëŠ” ì»¨í…ìŠ¤íŠ¸ë¥¼ ì¬ì‹œì‘í•˜ê±°ë‚˜ ìƒˆë¡œê³ ì¹¨í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. |
| RequestHandledEvent | ëª¨ë“  ë¹ˆë“¤ì—ê²Œ http ìš”ì²­ì´ ì„œë¹„ìŠ¤ë˜ì—ˆìŒì„ ì•Œë¦¬ëŠ” ì›¹ ê´€ë ¨ ì´ë²¤íŠ¸ì…ë‹ˆë‹¤. ì´ ì´ë²¤íŠ¸ëŠ” ìš”ì²­ ì²˜ë¦¬ê°€ ì™„ë£Œëœ ì‹œì ì— ë°œìƒí•©ë‹ˆë‹¤. ìŠ¤í”„ë§ì˜ `DispatcherServlet`ë¥¼ ì‚¬ìš©í•˜ëŠ” ì›¹ ì–´í”Œë¦¬ì¼€ì´ì…˜ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤. |
| ServletRequestHandledEvent | `RequestHandledEvent`ì˜ ìì‹ í´ë˜ìŠ¤ë¡œ ì„œë¸”ë¦¿ ê´€ë ¨ ì •ë³´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤. |

ìì‹ ë§Œì˜ ì´ë²¤íŠ¸ë¥¼ ë§Œë“¤ì–´ ë°œìƒì‹œí‚¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì˜ˆì œëŠ” ìŠ¤í”„ë§ì˜ `ApplicationEvent`ë¥¼ ìƒì†í•œ ê°„ë‹¨í•œ ì˜ˆì œì…ë‹ˆë‹¤.

```java
public class BlockedListEvent extends ApplicationEvent {

    private final String address;
    private final String content;

    public BlockedListEvent(Object source, String address, String content) {
        super(source);
        this.address = address;
        this.content = content;
    }

    // accessor and other methods...
}
```

ì‚¬ìš©ì ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¤ê¸°ìœ„í•´ì„œ `ApplicationEventPublisher`ì˜ publishEvent() ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. ì¼ë°˜ì ìœ¼ë¡œ `ApplicationEventPublisherAware`ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤ë¥¼ ìŠ¤í”„ë§ ë¹ˆìœ¼ë¡œ ë“±ë¡í•¨ìœ¼ë¡œì¨ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤. ì•„ë˜ ì˜ˆì œë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

```java
public class EmailService implements ApplicationEventPublisherAware {

    private List<String> blockedList;
    private ApplicationEventPublisher publisher;

    public void setBlockedList(List<String> blockedList) {
        this.blockedList = blockedList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String content) {
        if (blockedList.contains(address)) {
            publisher.publishEvent(new BlockedListEvent(this, address, content));
            return;
        }
        // send email...
    }
}
```

ë¹ˆ ì„¤ì • ë‹¨ê³„ì—ì„œ, ìŠ¤í”„ë§ ì»¨í…Œì´ë„ˆëŠ” `ApplicationEventPublisherAware`ë¥¼ êµ¬í˜„í•œ EmailServiceë¥¼ ë°œê²¬í•´ì„œ ìë™ìœ¼ë¡œ setApplicationEventPublisher()ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤. ì‹¤ì œë¡œ, ì¸ìë¡œ ìŠ¤í”„ë§ ì»¨í…Œì´ë„ˆ ìì‹ ì„ ì „ë‹¬í•©ë‹ˆë‹¤. `ApplicationEventPublisher` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ìŠ¤í”„ë§ ì»¨í…ìŠ¤íŠ¸ì™€ ìƒí˜¸ì‘ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì‚¬ìš©ì ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•˜ë ¤ë©´, `ApplicationListener` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ í´ë˜ìŠ¤ë¥¼ ë¹ˆìœ¼ë¡œ ë“±ë¡í•´ì•¼í•©ë‹ˆë‹¤. ì•„ë˜ ì˜ˆì œë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

```java
public class BlockedListNotifier implements ApplicationListener<BlockedListEvent> {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlockedListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
```


`ApplicationListener`ëŠ” ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ì ì´ë²¤íŠ¸ íƒ€ì…(ìœ„ ì˜ˆì œì˜ BlockedListEvent)ì— ë”°ë¼ ë§¤ê°œ ë³€ìˆ˜í™”ë©ë‹ˆë‹¤. ë³€ìˆ˜í™” ë•ë¶„ì— onApplicationEvent() ë©”ì†Œë“œëŠ” ìºìŠ¤íŒ… ì‘ì—… ì—†ì´, ì‚¬ìš©ì ì´ë²¤íŠ¸ íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆë¥¼ ì›í•˜ëŠ”ë§Œí¼ ë“±ë¡í•  ìˆ˜ ìˆê³ , ê¸°ë³¸ì ìœ¼ë¡œ ë¦¬ìŠ¤ë„ˆëŠ” ë™ê¸°ì ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤. ì¦‰, publishEvent() ë©”ì†Œë“œëŠ” ëª¨ë“  ë¦¬ìŠ¤ë„ˆê°€ ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•  ë•Œ ê¹Œì§€ block ìƒíƒœë¥¼ ìœ ì§€í•©ë‹ˆë‹¤. ì´ ë°©ì‹ì˜ ì¥ì ì€ ë¦¬ìŠ¤ë„ˆê°€ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í–ˆì„ ë•Œ, transaction ì»¨í…ìŠ¤íŠ¸ê°€ í™œì„±í™” ë˜ì–´ìˆë‹¤ë©´, transaction ì»¨í…ìŠ¤íŠ¸ ë‚´ì—ì„œ ë™ì‘í•©ë‹ˆë‹¤. ë§Œì•½ ì´ë²¤íŠ¸ ë°œìƒì „ëµì„ ë³€ê²½í•´ì•¼ í•œë‹¤ë©´, ìŠ¤í”„ë§ì˜ [`ApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.3.23/javadoc-api/org/springframework/context/event/ApplicationEventMulticaster.html) ì¸í„°í˜ì´ìŠ¤ì™€ [`SimpleApplicationEventMulticaster`](https://docs.spring.io/spring-framework/docs/5.3.23/javadoc-api/org/springframework/context/event/SimpleApplicationEventMulticaster.html) êµ¬í˜„ì²´ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.


ì‚¬ìš©ì ì´ë²¤íŠ¸ ì˜ˆì œë¥¼ ë¹ˆìœ¼ë¡œ ë“±ë¡í•œ ì˜ˆì œì…ë‹ˆë‹¤.

```xml
<bean id="emailService" class="example.EmailService">
    <property name="blockedList">
        <list>
            <value>known.spammer@example.org</value>
            <value>known.hacker@example.org</value>
            <value>john.doe@example.org</value>
        </list>
    </property>
</bean>

<bean id="blockedListNotifier" class="example.BlockedListNotifier">
    <property name="notificationAddress" value="blockedlist@example.org"/>
</bean>
```

emailService.sendEmail() ë©”ì†Œë“œê°€ í˜¸ì¶œë  ë•Œ, ì „ì†¡ ì œí•œëœ ì´ë©”ì¼ ì£¼ì†Œë¼ë©´, BlockedList ì´ë²¤íŠ¸ê°€ ë°œìƒí•©ë‹ˆë‹¤. `ApplicationListener`ë¡œ ë“±ë¡ëœ blockedListNotifier ë¹ˆì€ ì´ë²¤íŠ¸ë¥¼ ìˆ˜ì‹ í•´, ê´€ë¦¬ìì—ê²Œ ì•Œë¦¼ì„ ë³´ëƒ…ë‹ˆë‹¤.

{% hint style="success" %}

#### ğŸ’¡ 

ìŠ¤í”„ë§ ì´ë²¤íŠ¸ ë©”ì»¤ë‹ˆì¦˜ì€ ê°™ì€ ì»¨í…ìŠ¤íŠ¸ ë‚´ ë¹ˆë“¤ë¼ë¦¬ ê°„ë‹¨í•˜ê²Œ í†µì‹ ì„ ìœ„í•´ì„œ ê³ ì•ˆë˜ì—ˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ë³´ë‹¤ ì •êµí•œ ì—”í„°í”„ë¼ì´ì¦ˆ í†µí•© ìš”êµ¬ë¥¼ ìœ„í•´ ë³„ë„ë¡œ ìœ ì§€ ê´€ë¦¬í•˜ëŠ” [Spring Integration](https://spring.io/projects/spring-integration/) í”„ë¡œì íŠ¸ëŠ” Spring í”„ë¡œê·¸ë˜ë° ëª¨ë¸ì„ ê¸°ë°˜ìœ¼ë¡œ í•˜ëŠ” ê°€ë³ê³  íŒ¨í„´ ì§€í–¥ì ì¸ ì´ë²¤íŠ¸ ì¤‘ì‹¬ ì•„í‚¤í…ì²˜ë¥¼ êµ¬ì¶•í•˜ê¸° ìœ„í•´ì„œ ì œê³µë©ë‹ˆë‹¤.

{% endhint %}


### Annotation-based Event Listeners

ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•´ì„œ ë¦¬ìŠ¤ë„ˆë¥¼ ë“±ë¡í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ ì˜ˆì œë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

```java
public class BlockedListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlockedListEvent(BlockedListEvent event) {
        // notify appropriate parties via notificationAddress...
    }
}
```

ë©”ì†Œë“œ ì¸ìëŠ” êµ¬ë…í•  ì´ë²¤íŠ¸ íƒ€ì…ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ì´ ë°©ì‹ì€ ë©”ì†Œë“œ ëª…ì„ ììœ ë¡­ê²Œ ì •í•˜ê³ , ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ì§€ ì•Šì•„ë„ ë˜ëŠ” ìœ ì—°í•œ ì¥ì ì´ ìˆìŠµë‹ˆë‹¤. ì´ë²¤íŠ¸ íƒ€ì…ì€ ì œë„¤ë¦­ì„ ì´ìš©í•´ì„œ ì¢€ ë” ì„¸ë¶„í™” í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

ë§Œì•½ ì—¬ëŸ¬ ì´ë²¤íŠ¸ë“¤ì„ êµ¬ë…í•˜ê³  ì‹¶ê±°ë‚˜, ì¸ìê°€ í•„ìš”ì—†ë‹¤ë©´ ì–´ë…¸í…Œì´ì…˜ ì†ì„±ì„ í†µí•´ì„œ ì´ë²¤íŠ¸ íƒ€ì… ì§€ì •ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. ì•„ë˜ ì˜ˆì œë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

```java
@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    // ...
}
```

ì¶”ê°€ì ìœ¼ë¡œ SpEL í‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ëŠ” ì–´ë…¸í…Œì´ì…˜ì˜ condition ì†ì„±ì„ ì´ìš©í•´ì„œ íŠ¹ì • ì´ë²¤íŠ¸ì—ë§Œ ë©”ì†Œë“œê°€ í˜¸ì¶œë˜ë„ë¡ ëŸ°íƒ€ì„ í•„í„°ë§ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤. 

ì´ë²¤íŠ¸ ë‚´ìš©ì´ my-eventì¸ ê²½ìš°ì—ë§Œ í˜¸ì¶œë˜ë„ë¡ ì¬ ì‘ì„±ëœ ì˜ˆì œì…ë‹ˆë‹¤.

```java
@EventListener(condition = "#blEvent.content == 'my-event'")
public void processBlockedListEvent(BlockedListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}
```

Each SpEL expression evaluates against a dedicated context. The following table lists the items made available to the context so that you can use them for conditional event processing:

SpEL í‘œí˜„ì‹ì€ ì»¨í…ìŠ¤íŠ¸ ë‚´ì—ì„œ í‰ê°€ë©ë‹ˆë‹¤. ì•„ë˜ í‘œëŠ” ì»¨í…ìŠ¤íŠ¸ ë‚´ conditional ì´ë²¤íŠ¸ ì‘ì—…ì„ ìœ„í•´ì„œ ì‚¬ìš©ê°€ëŠ¥í•œ í•­ëª©ë“¤ì…ë‹ˆë‹¤.

| Name | Location | Description | Example |
|--|--|--|--|
| Event | root object | ì‹¤ì œ ApplicationEvent | #root.event or event |
| Arguments array | root object | ë©”ì†Œë“œë¥¼ í˜¸ì¶œí•˜ê¸° ìœ„í•œ ì¸ìë“¤(Object ë°°ì—´í˜•íƒœ) | #root.args or args; args[0] to access the first argument, etc. |
| Argument name | evaluation context | ë©”ì†Œë“œ ì¸ìëª…, ë§Œì•½ ì»´íŒŒì¼ëœ ë°”ì´íŠ¸ì½”ë“œì—ì„œ debug ì •ë³´ê°€ ì—†ì–´ì„œ ì¸ìëª…ì„ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤ë©´, ê°œë³„ ì¸ìë“¤ì€ `#a<#arg>` ì¸ë±ìŠ¤ ë°©ì‹ìœ¼ë¡œ ì°¸ì¡° ê°€ëŠ¥í•©ë‹ˆë‹¤. | #blEvent or #a0 (you can also use #p0 or #p<#arg> parameter notation as an alias)

ì‹¤ì œë¡œ ë©”ì†Œë“œì—ì„œëŠ” ì‚¬ìš©ì ì •ì˜ ì´ë²¤íŠ¸ ê°ì²´ë¥¼ ì „ë‹¬ë°›ë”ë¼ë„, #root.eventëŠ” ì´ë²¤íŠ¸ ê°ì²´ì— ëŒ€í•œ ì ‘ê·¼ì„ í—ˆìš©í•©ë‹ˆë‹¤. 

ë§Œì•½ ì´ë²¤íŠ¸ ì²˜ë¦¬ê²°ê³¼ë¡œ ë‹¤ë¥¸ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œì•¼ í•œë‹¤ë©´, ì´ë²¤íŠ¸ ë©”ì†Œë“œì—ì„œ ë°œìƒì‹œí‚¬ ì´ë²¤íŠ¸ë¥¼ ë°˜í™˜í•´ì•¼í•©ë‹ˆë‹¤. ì•„ë˜ ì˜ˆì œë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

```java
@EventListener
public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}
```

{% hint style="success" %}

#### ğŸ’¡ 

ì´ ê¸°ëŠ¥ì€ ë¹„ë™ê¸° ë¦¬ìŠ¤ë„ˆì—ì„œëŠ” ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.

{% endhint %}

handleBlockedListEvent() ì´ë²¤íŠ¸ ë©”ì†Œë“œëŠ” `BlockedListEvent` ì´ë²¤íŠ¸ë¥¼ ì²˜ë¦¬í•  ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ `ListUpdateEvent`ë¥¼ ë°œìƒì‹œí‚µë‹ˆë‹¤. ë§Œì•½ ì—¬ëŸ¬ ì´ë²¤íŠ¸ë¥¼ ë°œìƒí•´ì•¼í•œë‹¤ë©´, ì´ë²¤íŠ¸ collection í˜¹ì€ ì´ë²¤íŠ¸ ë°°ì—´ì„ ë°˜í™˜í•´ì•¼í•©ë‹ˆë‹¤.

### Asynchronous Listeners

`@Async`ë¥¼ í†µí•´ì„œ ë¹„ë™ê¸° ë¦¬ìŠ¤ë„ˆë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

```java
@EventListener
@Async
public void processBlockedListEvent(BlockedListEvent event) {
    // BlockedListEvent is processed in a separate thread
}
```

ë¹„ë™ê¸° ì´ë²¤íŠ¸ë¥¼ ì´ìš©í•  ë•Œ ë‹¤ìŒê³¼ ê°™ì€ ì œí•œì ì´ ìˆìŠµë‹ˆë‹¤.

* ë¹„ë™ê¸°ì—ì„œ ë°œìƒí•œ ì˜ˆì™¸ëŠ”, í˜¸ì¶œìì—ê²Œ ì „ë‹¬ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. `AsyncUncaughtExceptionHandler`ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.
* ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆì—ì„œ ì´ë²¤íŠ¸ë¥¼ ë°˜í™˜í•¨ìœ¼ë¡œì¨, ìˆœì°¨ì ìœ¼ë¡œ ë‹¤ìŒ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œí‚¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë§Œì•½ ë‹¤ë¥¸ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œì•¼ í•œë‹¤ë©´ `ApplicationEventPublisher`ë¥¼ ì´ìš©í•´ì„œ ì§ì ‘ ì´ë²¤íŠ¸ë¥¼ ë°œìƒì‹œì¼œì•¼ í•©ë‹ˆë‹¤.

### Ordering Listeners

ë¦¬ìŠ¤ë„ˆ ìˆœì„œë¥¼ ì •ì˜í•˜ë ¤ë©´ `@Order` ì–´ë…¸í…Œì´ì…˜ì„ ì´ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
@EventListener
@Order(42)
public void processBlockedListEvent(BlockedListEvent event) {
    // notify appropriate parties via notificationAddress...
}
```

### Generic Events

ì œë„¤ë¦­ì„ ì´ìš©í•´ì„œ ì‚¬ìš©ì ì´ë²¤íŠ¸ë¥¼ êµ¬ì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ìŒì€ Person ì—”í‹°í‹°ê°€ ìƒì„±ë  ë•Œë§Œ í˜¸ì¶œë˜ëŠ” ë¦¬ìŠ¤ë„ˆ ì˜ˆì œì…ë‹ˆë‹¤.

```java
@EventListener
public void onPersonCreated(EntityCreatedEvent<Person> event) {
    // ...
}
```

type erasureë¡œ ì¸í•´, ì œë„¤ë¦­ íƒ€ì…ìœ¼ë¡œ ëŒ€ìƒì„ í•„í„°í•  ìˆ˜ ìˆëŠ” ê²½ìš°ì—ë§Œ ë™ì‘í•©ë‹ˆë‹¤.(ì¦‰, PersonCreatedEvent extends EntityCreatedEvent<Person> { â€¦â€‹ }ì˜ ê²½ìš°)

íŠ¹ì • í™˜ê²½ì—ì„œëŠ”, ì´ ì‘ì—…ì´ ë¶€ë‹´ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê²½ìš°ì—ëŠ”, `ResolvableTypeProvider` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•´ ë¶€ì¡±í•œ ëŸ°íƒ€ì„ ì •ë³´ë¥¼ ëŒ€ì‹ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```java
public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource()));
    }
}
```

{% hint style="success" %}

#### ğŸ’¡ 

ì´ ë°©ì‹ì€ `ApplicationEvent` ë¿ë§Œì•„ë‹ˆë¼ ì‚¬ìš©ì ì´ë²¤íŠ¸ ê°ì²´ì—ë„ ì ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.

{% endhint %}


## 1.15.3. Convenient Access to Low-level Resources

ì–´í”Œë¦¬ì¼€ì´ì…˜ ì»¨í…ìŠ¤íŠ¸ë¥¼ ìµœì ìœ¼ë¡œ ì‚¬ìš©í•˜ê³  ì´í•´í•˜ë ¤ë©´, [Resources](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#resources)íŒŒíŠ¸ì—ì„œ ì„¤ëª…í•œ ìŠ¤í”„ë§ì˜ ë¦¬ì†ŒìŠ¤ ì¶”ìƒí™”ì— ìµìˆ™í•´ì ¸ì•¼í•©ë‹ˆë‹¤.

ì–´í”Œë¦¬ì¼€ì´ì…˜ ì»¨í…ìŠ¤íŠ¸ëŠ” ë¦¬ì†ŒìŠ¤ ê°ì²´ë“¤ì„ ë¡œë“œí•˜ëŠ” ë¦¬ì†ŒìŠ¤ ë¡œë”ì…ë‹ˆë‹¤. ë¦¬ì†ŒìŠ¤ëŠ” JDK `java.net.URL` í´ë˜ìŠ¤ì—ì„œ ì¤‘ìš”í•œ ê¸°ëŠ¥ë“¤ì„ ì¶”ê°€í•œ ë²„ì „ì…ë‹ˆë‹¤. ì‚¬ì‹¤ ë¦¬ì†ŒìŠ¤ êµ¬í˜„ì²´ë“¤ì€ ìœ íš¨í•œ `java.net.URL` ê°ì²´ë¥¼ ê°ì‹¸ê³  ìˆìŠµë‹ˆë‹¤. ë¦¬ì†ŒìŠ¤ëŠ” ë§Œì•½ ë¦¬ì†ŒìŠ¤ ìœ„ì¹˜ê°€ íŠ¹ë³„í•œ ì ‘ë‘ì‚¬ê°€ ì—†ëŠ” ë‹¨ìˆœ ê²½ë¡œë©´ì„œ, ì»¨í…ìŠ¤íŠ¸ íƒ€ì…ì— ì ì ˆí•˜ë‹¤ë©´, í´ë˜ìŠ¤ ê²½ë¡œ, íŒŒì¼ ì‹œìŠ¤í…œ, í‘œì¤€ URLì„ ì‚¬ìš©í•˜ì—¬ ì„¤ëª…í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ìœ„ì¹˜ ë° ê¸°íƒ€ ìœ„ì¹˜ì—ì„œ ë‚®ì€ ìˆ˜ì¤€ì˜ ë¦¬ì†ŒìŠ¤ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. 

`ResourceLoaderAware` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•œ ë¹ˆë“¤ì´ ì»¨íƒìŠ¤íŠ¸ ë‚´ ë°°í¬ë  ë•Œ, ìë™ìœ¼ë¡œ ì–´í”Œë¦¬ì¼€ì´ì…˜ ì»¨í…ìŠ¤íŠ¸ ìì²´ê°€ `ResourceLoader`ë¡œ ì´ˆê¸°í™” ì‹œì ì— ì „ë‹¬ë©ë‹ˆë‹¤. ë˜í•œ ì •ì  ë¦¬ì†ŒìŠ¤ë“¤ì„ ì°¸ì¡°í•˜ê¸° ìœ„í•´ì„œ Resourceíƒ€ì…ì˜ í”„ë¡œí¼í‹°ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¦¬ì†ŒìŠ¤ë“¤ì€ ë‹¤ë¥¸ í”„ë¡œí¼í‹°ë“¤ê³¼ ê°™ì´ ì£¼ì…ë©ë‹ˆë‹¤. ë¹ˆì´ ë°°í¬ë  ë•Œ, ë‹¨ìˆœ ê²½ë¡œë¡œ í‘œí˜„í•œ ë¦¬ì†ŒìŠ¤ í”„ë¡œí¼í‹°ë“¤ì€ ì‹¤ì œ ë¦¬ì†ŒìŠ¤ ê°ì²´ë¡œ ë³€í™˜ë©ë‹ˆë‹¤.

ì»¨í…ìŠ¤íŠ¸ ìƒì„±ìì— ì œê³µëœ ë‹¨ìˆœ ë¬¸ìì—´ì˜ ë¦¬ì†ŒìŠ¤ ê²½ë¡œë“¤ì€ ì»¨í…ìŠ¤íŠ¸ êµ¬í˜„ì²´ì— ë”°ë¼ ì ì ˆí•˜ê²Œ ì²˜ë¦¬ë©ë‹ˆë‹¤. ì˜ˆë¥¼ë“¤ë©´ `ClassPathXmlApplicationContext`ëŠ” ë‹¨ìˆœ ë¦¬ì†ŒìŠ¤ ê²½ë¡œë¥¼ í´ë˜ìŠ¤ íŒ¨ìŠ¤ ê²½ë¡œë¡œ ì¸ì‹í•©ë‹ˆë‹¤. ë˜í•œ íŠ¹ë³„í•œ ì ‘ë‘ì‚¬ì˜ ë¦¬ì†ŒìŠ¤ ê²½ë¡œë¥¼ ì‚¬ìš©í•´ì„œ ì»¨í…ìŠ¤íŠ¸ íƒ€ì…ì— ê´€ê³„ì—†ì´ í´ë˜ìŠ¤íŒ¨ìŠ¤ í˜¹ì€ URLìœ¼ë¡œë¶€í„° ë¦¬ì†ŒìŠ¤ë¥¼ ë¡œë“œí•˜ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## 1.15.4. Application Startup Tracking

The ApplicationContext manages the lifecycle of Spring applications and provides a rich programming model around components. As a result, complex applications can have equally complex component graphs and startup phases.

Tracking the application startup steps with specific metrics can help understand where time is being spent during the startup phase, but it can also be used as a way to better understand the context lifecycle as a whole.

The AbstractApplicationContext (and its subclasses) is instrumented with an ApplicationStartup, which collects StartupStep data about various startup phases:

application context lifecycle (base packages scanning, config classes management)

beans lifecycle (instantiation, smart initialization, post processing)

application events processing

Here is an example of instrumentation in the AnnotationConfigApplicationContext:

```java
// create a startup step and start recording
StartupStep scanPackages = this.getApplicationStartup().start("spring.context.base-packages.scan");
// add tagging information to the current step
scanPackages.tag("packages", () -> Arrays.toString(basePackages));
// perform the actual phase we're instrumenting
this.scanner.scan(basePackages);
// end the current step
scanPackages.end();
```

The application context is already instrumented with multiple steps. Once recorded, these startup steps can be collected, displayed and analyzed with specific tools. For a complete list of existing startup steps, you can check out the dedicated appendix section.

The default ApplicationStartup implementation is a no-op variant, for minimal overhead. This means no metrics will be collected during application startup by default. Spring Framework ships with an implementation for tracking startup steps with Java Flight Recorder: FlightRecorderApplicationStartup. To use this variant, you must configure an instance of it to the ApplicationContext as soon as itâ€™s been created.

Developers can also use the ApplicationStartup infrastructure if theyâ€™re providing their own AbstractApplicationContext subclass, or if they wish to collect more precise data.

ApplicationStartup is meant to be only used during application startup and for the core container; this is by no means a replacement for Java profilers or metrics libraries like Micrometer.
To start collecting custom StartupStep, components can either get the ApplicationStartup instance from the application context directly, make their component implement ApplicationStartupAware, or ask for the ApplicationStartup type on any injection point.

Developers should not use the "spring.*" namespace when creating custom startup steps. This namespace is reserved for internal Spring usage and is subject to change.

### 1.15.5. Convenient ApplicationContext Instantiation for Web Applications

You can create ApplicationContext instances declaratively by using, for example, a ContextLoader. Of course, you can also create ApplicationContext instances programmatically by using one of the ApplicationContext implementations.

You can register an ApplicationContext by using the ContextLoaderListener, as the following example shows:

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value>
</context-param>

<listener>
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```

The listener inspects the contextConfigLocation parameter. If the parameter does not exist, the listener uses /WEB-INF/applicationContext.xml as a default. When the parameter does exist, the listener separates the String by using predefined delimiters (comma, semicolon, and whitespace) and uses the values as locations where application contexts are searched. Ant-style path patterns are supported as well. Examples are /WEB-INF/*Context.xml (for all files with names that end with Context.xml and that reside in the WEB-INF directory) and /WEB-INF/**/*Context.xml (for all such files in any subdirectory of WEB-INF).


### 1.15.6. Deploying a Spring ApplicationContext as a Java EE RAR File

It is possible to deploy a Spring ApplicationContext as a RAR file, encapsulating the context and all of its required bean classes and library JARs in a Java EE RAR deployment unit. This is the equivalent of bootstrapping a stand-alone ApplicationContext (only hosted in Java EE environment) being able to access the Java EE servers facilities. RAR deployment is a more natural alternative to a scenario of deploying a headless WAR fileâ€‰â€”â€‰in effect, a WAR file without any HTTP entry points that is used only for bootstrapping a Spring ApplicationContext in a Java EE environment.

RAR deployment is ideal for application contexts that do not need HTTP entry points but rather consist only of message endpoints and scheduled jobs. Beans in such a context can use application server resources such as the JTA transaction manager and JNDI-bound JDBC DataSource instances and JMS ConnectionFactory instances and can also register with the platformâ€™s JMX serverâ€‰â€”â€‰all through Springâ€™s standard transaction management and JNDI and JMX support facilities. Application components can also interact with the application serverâ€™s JCA WorkManager through Springâ€™s TaskExecutor abstraction.

See the javadoc of the SpringContextResourceAdapter class for the configuration details involved in RAR deployment.

For a simple deployment of a Spring ApplicationContext as a Java EE RAR file:

Package all application classes into a RAR file (which is a standard JAR file with a different file extension).

Add all required library JARs into the root of the RAR archive.

Add a META-INF/ra.xml deployment descriptor (as shown in the javadoc for SpringContextResourceAdapter) and the corresponding Spring XML bean definition file(s) (typically META-INF/applicationContext.xml).

Drop the resulting RAR file into your application serverâ€™s deployment directory.

Such RAR deployment units are usually self-contained. They do not expose components to the outside world, not even to other modules of the same application. Interaction with a RAR-based ApplicationContext usually occurs through JMS destinations that it shares with other modules. A RAR-based ApplicationContext may also, for example, schedule some jobs or react to new files in the file system (or the like). If it needs to allow synchronous access from the outside, it could (for example) export RMI endpoints, which may be used by other application modules on the same machine.



